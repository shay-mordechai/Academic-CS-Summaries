

![[Pasted image 20251126123428.png]]
![[Pasted image 20251126123448.png]]

![[Pasted image 20251126123902.png]]

משפט האוניברסליות
משפט הפרמטר
שלמות ל-m

הנה הסבר על שני המשפטים הללו וכיצד הם מהווים את הבסיס לביצוע רדוקציות בחישוביות.

### 1. משפט האוניברסליות (The Universality Theorem)

המשפט הזה הוא הבסיס לקיום מחשבים כפי שאנו מכירים אותם היום (מחשב אחד שיכול להריץ תוכנות שונות).

- **ההגדרה:** לכל מספר משתנים $n$, קיימת פונקציה אוניברסלית חישובית (מסומנת ב-$\Phi^{(n)}$) שיודעת "לחקות" כל תוכנית אחרת.
    
- **איך זה עובד?** הפונקציה מקבלת כקלט:
    
    1. את הנתונים הרגילים ($x_1, ..., x_n$).
        
    2. משתנה נוסף ($x_{n+1}$) שהוא **הקידוד (המספר)** של התוכנית שאותה רוצים להריץ.
        
- **המשמעות:** זהו ה"מפרש" (Interpreter). במקום לבנות מכונה פיזית נפרדת לחיבור ומכונה נפרדת לכפל, בונים מכונה אחת (האוניברסלית) שיודעת לקבל "קוד" של חיבור ולבצע חיבור, או "קוד" של כפל ולבצע כפל.

אז משפט האוניברסליות עוזר לנו לדברים האלה:

- רדוקציה
    
- ליכסון
    
- מציאת אלגוריתם T להוכחת במ"ר.

זוהי קביעה מדויקת ביותר המאגדת את תפקידיו המרכזיים של **משפט האוניברסליות** והתוצאות הנגזרות ממנו בתורת החישוביות. **התשובה היא חיובית**; משפט האוניברסליות הוא הליבה התיאורטית המאפשרת את כל שלושת הכלים הללו.

התכנית האוניברסלית (הפונקציה $\mathbf{\Phi}$), אשר קיומה מוכח במשפט האוניברסליות, היא **פונקציה חישובית חלקית** המקבלת קידוד של תכנית ($y$) וקלט ($x_1, \dots, x_n$), ומחזירה את תוצאת ההרצה של אותה תכנית. יכולת זו לדמות כל תכנית היא הבסיס לשיטות ההוכחה שציינת:

### 1. רדוקציה (Reduction)

משפט האוניברסליות **חיוני** לבנייה ולהוכחת החישוביות של פונקציות רדוקציה ($f$).

- **הגדרת רדוקציה:** רדוקציה ($A \le_m B$) דורשת קיום של **פונקציה חישובית** $f$ שממפה איברים מ-$A$ ל-$B$.
- **הבנייה:** כאשר אנו בונים תכנית חדשה ($P_n$) במסגרת הרדוקציה, ההתנהגות של $P_n$ תלויה לרוב ב**הרצת תכנית אחרת** (או עצמה) על קלט מסוים. תכנית זו ($P_n$) מוגדרת כמעט תמיד באמצעות קריאה לפונקציה $\mathbf{\Phi}$. לדוגמה, בהוכחת רדוקציה מ-$\mathbf{K}$ לקבוצה $A_{f}$ (קבוצת התכניות המחשבות פונקציה $f$), התכנית הבנויה כוללת את ההוראה $\mathbf{Z \leftarrow \Phi^{(1)}(n, n)}$ כדי לבדוק השתייכות ל-$\mathbf{K}$.
- **הוכחת חישוביות:** העובדה ש-$f$ היא פונקציה חישובית (הכרחית לרדוקציה) מוכחת לעתים קרובות באמצעות צירוף של **משפט הפרמטר** (שבעצמו נסמך על הקידוד והאוניברסליות) ו**משפט האוניברסליות**.

### 2. ליכסון (Diagonalization)

משפט האוניברסליות הוא המושג המכונן המאפשר בכלל לדבר על האלכסון בהקשר של חישוביות.

- **מספור פונקציות:** הליכסון עובד על ידי הנחה שקיימת רשימה ממוספרת של כל הפונקציות החישוביות החלקיות. פונקציה זו, $\mathbf{\Phi^{(n)}(x_1, \dots, x_n, y)}$, היא ה**תכנית האוניברסלית** אשר מחשבת את הפלט של תכנית שמקודדת על ידי $y$. משפט האוניברסליות מבטיח שכל פונקציה חישובית חלקית כלשהי מופיעה ברשימה זו.
- **הגדרת HALT ו-K:** ההוכחה הקלאסית של האלכסון מוכיחה ש**הפרדיקט $\mathbf{HALT}(x, y)$ אינו חישובי**. פרדיקט זה מוגדר פורמלית על בסיס **עצירת** הפונקציה האוניברסלית ($\mathbf{\Phi}(x, y) \downarrow$). קבוצת העצירה העצמית ($\mathbf{K}$), שהיא מוקד ההוכחה הדיאגונלית, מוגדרת כמקרה פרטי של הפונקציה האוניברסלית: $\mathbf{K = {n \in N: \Phi^{(1)}(n, n) \downarrow}}$.

### 3. מציאת אלגוריתם $\mathbf{T}$ להוכחת $\mathbf{במ"ר}$ (r.e. status)

כדי להוכיח שקבוצה $B$ היא $\mathbf{במ"ר}$ (כלומר, קיימת עבורה תכנית $T$ העוצרת אם ורק אם $x \in B$), נדרשת הוכחה פורמלית באמצעות ייצוג באמצעות כימות קיום לא חסום ($\exists t$) על פרדיקט $\mathbf{ר"פ}$.

- **האפיון באמצעות $\mathbf{STP}$:** הייצוג הפורמלי של תכנית $T$ כאלגוריתם כריעות חלקית נעשה באמצעות **פרדיקט מונה הצעדים ($\mathbf{STP}$)**.
- **הקשר ל-$\mathbf{\Phi}$:** הפרדיקטים $\mathbf{STP}$ ו-$\mathbf{SNAP}$ (תמונה רגעית) הם כלים שפותחו **במהלך בניית ההוכחה** לקיום התכנית האוניברסלית. הפונקציה $\mathbf{SNAP}$ מציגה את המצב הרגעי של התכנית לאחר $t$ צעדים, ו-$\mathbf{STP}$ בודק אם התכנית עצרה עד צעד $t$.
- **הצורה הנורמלית:** הפיתוח של $\mathbf{STP}$ ו-$\mathbf{SNAP}$ מאפשר את ניסוח **משפט הצורה הנורמאלית**, הקובע שכל פונקציה חישובית חלקית (כמו $T$ שמקבלת את $B$) ניתנת לייצוג באמצעות מינימיזציה לא חסומה המופעלת על פרדיקט $\mathbf{ר"פ}$ שנבנה באמצעות כלים אלו.

לכן, משפט האוניברסליות, על ידי הגדרתו הפורמלית של מודל החישוב ופיתוח הכלים הנלווים ($\mathbf{STP}$, $\mathbf{SNAP}$), משמש **כמקור תיאורטי ופורמלי** לכל אחת משלוש הדרכים שציינת.
### 2. משפט הפרמטר (The Parameter Theorem / s-m-n Theorem)

משפט זה (הנקרא גם משפט s-m-n) עוסק ביכולת לבצע מניפולציה על קוד של תוכניות באופן אלגוריתמי.

- **ההגדרה:** אם יש לנו תוכנית שמקבלת שני סוגי קלטים (למשל $x$ ו-$y$), ניתן "לקבע" (Hardcode) את הקלט הראשון ($x$) לערך ספציפי, ולקבל **קוד חדש** של תוכנית שמקבלת רק את הקלט השני ($y$) ומבצעת את אותו חישוב.
    
- **החלק החשוב:** המעבר מהקוד הכללי לקוד הספציפי הוא **חישובי** (נעשה ע"י פונקציה רקורסיבית פרימיטיבית שנקראת $S$). כלומר, אפשר לכתוב תוכנית מחשב שכותבת תוכניות מחשב אחרות.
    
- **דוגמה:** נניח שיש תוכנית $P$ שמחשבת $f(x,y) = x+y$. אם נחליט ש-$x=5$, משפט הפרמטר אומר שאנחנו יכולים לחשב את המספר הסידורי (הקוד) של תוכנית חדשה $Q$, שמחשבת רק $g(y) = 5+y$.
    

### האם זה קשור לרדוקציות?

**כן, באופן קריטי.** שני המשפטים האלו הם כלי העבודה העיקריים בבניית רדוקציות (Reductions) להוכחת אי-כריעות.

כאשר אנו עושים רדוקציה (למשל, מבעיית העצירה $HALT$ לבעיה אחרת $A$), אנחנו לרוב צריכים לבנות פונקציה $f$ שלוקחת קלט של הבעיה הראשונה וממירה אותו לקלט של הבעיה השנייה.

השימוש במשפטים בתוך רדוקציה נראה כך:

1. אנחנו רוצים לבנות מכונה ספציפית שתתנהג בצורה מסוימת _רק אם_ הקלט המקורי $x$ גורם לתוכנית המקורית לעצור.
    
2. כדי לבנות את המכונה הזו, אנחנו משתמשים ב**משפט הפרמטר** כדי "לשתול" (Hardcode) את הקלט $x$ בתוך הקוד של המכונה החדשה.
    
3. המכונה החדשה משתמשת ב**תוכנית האוניברסלית** כדי להריץ את הסימולציה של התוכנית המקורית על הקלט המושתל.
    

לסיכום:

בלי משפט האוניברסליות, לא היינו יכולים לכתוב תוכנית שמריצה תוכנית אחרת.

בלי משפט הפרמטר, לא היינו יכולים לכתוב רדוקציה שבונה קוד של מכונה חדשה על סמך קלט נתון.



"שלמות ל-m" (m-completeness) הוא לא משפט, אלא **תכונה** של בעיה (או שפה). זהו מושג מרכזי מאוד בנושא הרדוקציות.

בוא נעשה סדר:

בחישוביות משתמשים ברדוקציות מסוג $m$ (רדוקציות "רבים-לאחד", המסומנות $\le_m$).

כשאומרים שבעיה $A$ היא "שלמה ל-m" (m-complete) במחלקה מסוימת (למשל, במחלקה RE - הניתנות למנייה), זה אומר שני דברים:

1. הבעיה $A$ עצמה שייכת למחלקה הזו (היא ניתנת למנייה).
    
2. **היא "הכי קשה" במחלקה:** כל בעיה אחרת במחלקה ניתנת לרדוקציה ($m$-reduction) אליה.
    

### למה זה חשוב לרדוקציות?

זהו בעצם ה"עוגן" של הרדוקציות.

בטבלה שהעלית (image_ff1e5c.png), הבעיות בשורות 4 ו-5 ($HALT$ והאלכסון $K$) הן דוגמאות קלאסיות לבעיות שהן m-שלמות (עבור מחלקת ה-RE).

החשיבות:

ברגע שהוכחנו שבעיה כמו $HALT$ היא "שלמה", היא הופכת לכלי העבודה העיקרי שלנו:

- אנחנו יודעים שהיא "קשה" (לא כריעה).
    
- כדי להוכיח שבעיה **חדשה** היא קשה, אנחנו פשוט עושים רדוקציה **מ-** $HALT$ **אל** הבעיה החדשה.
    
- בגלל ש-$HALT$ היא "הכי קשה", אם הבעיה החדשה מצליחה לפתור את $HALT$, סימן שגם היא "הכי קשה".
    

לסיכום:

"שלמות ל-m" היא התואר שניתן לבעיות ה"אב" (כמו $HALT$), שמהן אנחנו מתחילים את רוב הרדוקציות כדי להוכיח אי-כריעות של בעיות אחרות.


שאלתך נוגעת לאחת מנקודות המפתח בתורת החישוביות: זיהוי הקבוצות ה"קשות ביותר" במחלקת הקבוצות בנות המנייה הרקורסיבית ($\mathbf{במ"ר}$).

הבעיות ה**שלמות ל-$m$** (m-complete) שחשוב לדעת לבחינה, הן אותן קבוצות המוגדרות כקבוצות $\mathbf{במ"ר}$ שהן הקשות ביותר במחלקתן, ומשמשות כבסיס לרדוקציות רבות אחרות.

### הגדרה פורמלית של שלמות ל-$m$

קבוצת $\mathbf{במ"ר}$ בשם $B$ נקראת **שלמה ל-$m$** אם מתקיימים שני תנאים:

1. $B$ היא **בת מנייה רקורסיבית** ($\mathbf{במ"ר}$).
2. לכל קבוצת $\mathbf{במ"ר}$ אחרת $A$, מתקיים $A \le_m B$.

תנאי זה קובע ש-$B$ היא הקבוצה שאליה ניתן לבצע רדוקציה מכל קבוצת $\mathbf{במ"ר}$ אחרת, באמצעות פונקציה חישובית.

### הקבוצות המרכזיות השלמות ל-$m$

הקבוצות הסטנדרטיות המוכחות כשלמות ל-$m$ הן שתי בעיות העצירה המרכזיות:

|שם הקבוצה|הגדרה|שלמות ל-$m$|
|:--|:--|:--|
|$\mathbf{K}$ (עצירה עצמית)|קבוצת כל התכניות $n$ אשר עוצרות על הקלט של עצמן: $\mathbf{K}={n \in N: \Phi(n, n) \downarrow}$|**שלמה ל-$m$**|
|$\mathbf{K_0}$ (עצירה כללית)|קבוצת כל הזוגות $\langle x, y \rangle$ כך שהתכנית $y$ עוצרת על הקלט $x$: $\mathbf{K_0}={\langle x, y \rangle: \Phi(x, y) \downarrow}$|**שלמה ל-$m$**|

**הערה לגבי $\mathbf{K}$ ו-$\mathbf{K_0}$:** הקבוצה $\mathbf{K_0}$ (בעיית העצירה הכללית) היא שלמה ל-$m$. למעשה, **כל קבוצת $\mathbf{במ"ר}$ ניתנת לרדוקציה ל-$\mathbf{K_0}$**. כמו כן, $\mathbf{K}$ ו-$\mathbf{K_0}$ הן **שקולות ל-$m$** ($\mathbf{K} \equiv_m \mathbf{K_0}$), ולכן גם $\mathbf{K}$ היא שלמה ל-$m$.

### קבוצות מרכזיות שאינן שלמות ל-$m$ (אך חשובות לבחינה)

בעיות רבות אחרות המורכבות ממספרי תכניות מוכחות כ**לא $\mathbf{במ"ר}$** על ידי רדוקציה מבעיות $\mathbf{במ"ר}$ קשות או המשלים של $\mathbf{K}$ ($\mathbf{\overline{K}}$). אם קבוצה אינה $\mathbf{במ"ר}$, היא אינה יכולה להיות שלמה ל-$m$.

דוגמאות לקבוצות ש**אינן $\mathbf{במ"ר}$** ומשמשות כבסיס לרדוקציות:

- **$\mathbf{TOT}$** (Total): קבוצת הקידודים של תכניות שהן **שלמות** (עוצרות על כל קלט). $\mathbf{TOT}$ אינה $\mathbf{במ"ר}$.
- **$\mathbf{EMPTY}$:** קבוצת הקידודים של תכניות שאינן עוצרות על **אף קלט** (תחום ההגדרה שלהן ריק). $\mathbf{EMPTY}$ אינה $\mathbf{במ"ר}$.
- **$\mathbf{\overline{K}}$** (המשלים של K): קבוצת התכניות ש**אינן עוצרות** על עצמן. $\mathbf{\overline{K}}$ אינה $\mathbf{במ"ר}$.

### הרחבה: בעיות שלמות ל-NP (NP-Complete)

אם בהקשר הכללי של הבחינה נדרשת ידיעה גם על מחלקת הסיבוכיות $\mathbf{NP}$, ישנן בעיות רבות המוגדרות כ**שלמות ל-NP** ($\mathbf{NP}$-Complete). אלו הבעיות ה"קשות ביותר" במחלקת $\mathbf{NP}$.

בעיות שלמות ל-NP המופיעות במקורות:

- **$\mathbf{SAT}$** (בעיית הספיקות), ובפרט **$\mathbf{SAT-3}$**.
- **$\mathbf{Clique}$** (קליקה).
- **$\mathbf{VC}$** (כיסוי קודקודים).
- **בעיית מעגל המילטון** (Hamiltonian Cycle).
- **$\mathbf{CONST}$** (קבוצת כל התכניות המחשבות פונקציה קבועה) הוכחה כ**שקולה ל-$m$ ל-$\mathbf{TOT}$** ($\mathbf{TOT} \equiv_m \mathbf{CONST}$), ולכן היא קבוצה **לא $\mathbf{במ"ר}$**.

**הערה:** אם בעיה $A$ היא שלמה ל-$\mathbf{NP}$, הוכחה שבעיה $B$ קשה לפחות כמוה (hard-NP) נעשית על ידי רדוקציה בזמן פולינומיאלי ($A \le_p B$).