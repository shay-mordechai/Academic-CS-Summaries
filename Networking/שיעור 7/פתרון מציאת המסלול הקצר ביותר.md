
**[Dijkstra Algorithm]{.underline}[: ]{dir="rtl"}**[אלגוריתם
זה]{dir="rtl"} [פועל ע\"י בחירה איטרטיבית של הצומת בעל העלות הנמוכה
ביותר מתוך]{dir="rtl"} [כל הצמתים הנבדקים]{dir="rtl"}. [תהליך זה נמשך עד
שמגיעים לצומת]{dir="rtl"} Z [או שביקרו בכל הצמתים. הנתיב]{dir="rtl"}
[שיתקבל יהיה המסלול הקצר ביותר מ]{dir="rtl"}-U [ל]{dir="rtl"}-Z [בהתבסס
על העלויות המצטברות]{dir="rtl"}.

> [שלבים:]{dir="rtl"}

-   [בחירת קודקוד התחלתי.]{dir="rtl"}

-   [ביצוע הקלה על כל שכניו.]{dir="rtl"}

    -   [הקלה על קודקוד היא בדיקה האם ניתן לשפר את ערכו, בהינתן קשת
        וקודקוד קודם.]{dir="rtl"}

-   [עוברים לקודוק הקרוב ביותר ממנו.]{dir="rtl"}

-   [מבצעים גם על כל שכניו הקלה.]{dir="rtl"}

-   [ממשיכים כך עד שעוברים על כל הקודקודים.]{dir="rtl"}

[תכונות:]{dir="rtl"}

-   [עושה בכל צעד את הבחירה הטובה ביותר, ולא מתחרט על כך (אלגוריתם
    חמדני).]{dir="rtl"}

-   [עובד ביעילות כאשר משקלי הקצה חיוביים. הוא מוצא את הנתיב]{dir="rtl"}
    [הקצר ביותר מקודקוד מקור לכל שאר הקודקודים בגרף]{dir="rtl"}.[\
    (]{dir="rtl"}waze [משתמשת באלגוריתם המבוסס על דיקסטרה,
    הנקרא]{dir="rtl"} A star[).]{dir="rtl"}

> [ ]{dir="rtl"}

**[Bellman & Ford Algorith]{.underline}[:]{dir="rtl"}** [בלמן-פורד:
אלגוריתם זה מוצא גם את הנתיב הקצר ביותר בגרף]{dir="rtl"}. [כל צומת מעדכן
באופן עצמאי את ערכי המרחק שלו בהתבסס על המידע של הצמתים השכנים
לו.]{dir="rtl"}

> [האלגוריתם:]{dir="rtl"}

-   [בוחרים קודקוד מקור. כל ערך קודקוד יחושב כמרחק מהמקור
    אליו.]{dir="rtl"}

-   [מבצעים הקלה על קשתות, בשונה מדיסטרה שביצענו על
    קודקודים.]{dir="rtl"}

-   [יש התייחסות לכיוון הגרף. לא נבדוק קשת שהיא נגד כיוון
    החץ.]{dir="rtl"}

-   [מספר האיטרציות שיש לבצע הן]{dir="rtl"} N-1 [כאשר]{dir="rtl"} N [זה
    מספר הקודקודים.\
     ]{dir="rtl"}

> \*[נבדוק שאין מעגלים שליליים. אם לא ניתן לבצע שוב הקלה על אחת מהקשתות,
> אין מעגל שלילי.]{dir="rtl"}

[תכונות:]{dir="rtl"}

-   [הוא אלגוריתם תכנות דינמי שיכול להתמודד עם גרפים עם]{dir="rtl"}
    [משקלי קצה שליליים. זה לא רק מחשב את הנתיב הקצר ביותר אלא גם מזהה
    מחזורים]{dir="rtl"} [שליליים בגרף]{dir="rtl"}.

-   [אם יש מחזור שלילי, הדרך הקצרה ביותר אינה מוגדרת היטב]{dir="rtl"}.

-   [בדרך כלל איטי יותר מהאלגוריתם של דיקסטרה בגלל הבדיקות]{dir="rtl"}
    [הנוספות שלו לאיתור מחזורים שליליים]{dir="rtl"}.

    -   [לכן, לעתים קרובות עדיף להשתמש באלגוריתם של דיקסטרה]{dir="rtl"}
        [כאשר לגרף יש רק משקלי קצה חיוביים, ובאלגוריתם]{dir="rtl"}
        Bellman-Ford [כאשר קיימים]{dir="rtl"} [משקלים שליליים או מחזורים
        שליליים]{dir="rtl"}.

> [ ]{dir="rtl"}
>
> [[אלגוריתמים למציאת המסלול הקצר ביותר:]{.underline}]{dir="rtl"}
>
> [ראשית, חשוב לקבוע]{dir="rtl"} [איזה אלגוריתם נרצה, **גלובלי או
> מקומי**.]{dir="rtl"}

1.  [גלובלי - לכל הנתבים יש מידע על עלות קישור של כל הנתבים ברשת (למשל
    ,]{dir="rtl"} link state[).]{dir="rtl"}

2.  [מקומי - הנתב מכיר רק את שכנים המחוברים פיזית.]{dir="rtl"}

> [\
> לכל גישה יש יתרונות וחסרונות משלה. אחת מציעה פשטות ביישום, בעוד השניה
> מספקת ניתוב מהיר יותר.\
>  ]{dir="rtl"}
>
> [לאחר מכן, עלינו לקבוע האם הרשת היא **סטטית או דינמית**.]{dir="rtl"}

3.  [ברשת סטטית - כתובות מוקצות פעם אחת ונשארות ללא שינוי. גישה זו עובדת
    היטב עבור רשתות קטנות שחוות שינויים מינימליים. המסלולים משתנים
    לאט.]{dir="rtl"}

4.  [ברשת דינמית - אלגוריתמי ניתוב נחוצים לטיפול בעדכונים ושינויים
    מתמשכים. זה נדרש בדרך כלל עבור רשתות גדולות יותר. מסלולים משתנים מהר
    יותר.\
     ]{dir="rtl"}

> [שתי שאלות אלו חיוניות בבחירת אלגוריתם הניתוב המתאים.]{dir="rtl"}
>
> [ ]{dir="rtl"}
