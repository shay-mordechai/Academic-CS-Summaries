
>
> 1. מה מגדיר SOCKET?
> א. שפת התכנות שממנה קראו לSOCKET.
> ב. כתובות הIP של היעד.
> **ג. כתובת הIIP של המחשב וכתובת PORT של האפליקציה שיזמה קריאה.**
> ד. כתובת הIP של המחשב ושל הנתב הראשי וכתובת הPORT של האפליקציה שיזמה קריאה.
> ה. כתובות הIP של היעד ומפתח ההצפנה.

> [מה מגדיר סוקט? - כדי להעביר חבילה למחשב, אני צריך לדעת מה
> ה]{dir="rtl"}IP [שלו והפורט. תשובה 3.]{dir="rtl"}
>
> 
> [מה מאפיין שירות לשיחת טלפון? תשובות א,ג,ה.]{dir="rtl"}
> **א. Loss Tolerant**
> ב. No Loss
> **ג. דרישה של קצב מינימאלי**
> ד. אין דרישה של קצב מינימאלי
> **ה. חסם עליון לDelay**
>
> [מה זה]{dir="rtl"} HTML[? - שפת ייצוג המשתמשת בתגיות. שפת]{dir="rtl"}
> markup[, שאני מסמן איך להציג דברים. זו לא שפת תכנות. החלק התכנותי
> מבוצע ע\"י ג\'אווה סקריפט וכו\', שמוסיפים דינמיות לדף.]{dir="rtl"}
> HTML [נותנת את הצד הסטטי.\
> שפה נוספת שהיא דקלרטיבית,]{dir="rtl"} XML [ועוד.]{dir="rtl"}
>
> מה זה HTML?
> א. שפה פשוטה מאוד בשם Hypet Text Model Language
> ב. שפה גמישה מאוד בשם Hypet Text Make-Up Language
> ג. שפה שהנתבים מבינים בשם Hypet Text Manage Language
**ד. שפה דקלרטיבית (Declarative) בשם Hypet Text Makeup Language**
> ה. השפה היחידה שיכולה לעבוד עם פרוטוקול URL ונקראת בשם Hypet Text Module Language.

>
> ![](image28.png)אם אני צריך להוריד רק אובייקט אחד באתר, מה השיטה העדיפה מבחינת השרת והעדיפה מבחינת הלקוח?
> א. לשרת עדיף Persistent, וללקוח Non Persistent.
> ב. לשניהם עדיף Persistent.
> ג. לשניהם עדיף Non Persistent.
> **ד. לשרת עדיף Non Persistent וללקוח זה לא משנה כי זה אובייקט אחד.**
> ה. לשניהם זה לא משנה כי זה רק אובייקט אחד
>
> [לשרת עדיף להישאר מחובר כי אולי הלקוח יבקש עוד דברים.\
> גם אם השרת יבחר בפרסיסטנט, זה יגרום לו לעומס כי יש לו המון לקוחות וזה
> יצריך ממנו לפתוח הרבה סוקטים.]{dir="rtl"}

> ![](image29.png)
מתי משתמשים בשיטת POST בHTTP?
א. כאשר רוצים הצפנה של המידע, לכן שמים מפתח בתוך הBODY.
ב. כאשר רוצים שהשרת יזהה אותנו דרך הCOOKIES רושמים בBODY פרטי משתמש.
ג. כאשר לא רוצים שהשרת יעבור על השדה BODY
**ד. כאשר המידע שרוצים למסור לשרת גדול מאשר מה שניתן לרשום בשורה הראשונה של הREQUEST.**
ה. כאשר משתמשים בשיטת PERSISTENT.

תשובה ד. בקשות]{dir="rtl"} POST [משמשות בדרך כלל לשליחה
של]{dir="rtl"} [מחרוזות]{dir="rtl"} [לשרת. למשל מחרוזות ארוכות, כגון
נתונים]{dir="rtl"} [בטפסי]{dir="rtl"} HTML, [לשם עיבוד]{dir="rtl"}.



>נתון HTML Response הבא:
>באיזו גרסה של HTTP השרת משתמש? (תמונה להמחשה)
>א. 1.0
>ב. 1.1
>ג. 404
>ד. 860
> [בעת ביצוע בקשת]{dir="rtl"} POST, [הנתונים נשלחים בגוף הודעת בקשת
> ה]{dir="rtl"}-HTTP, [ולא בכתובת ה]{dir="rtl"}-URL. [זה מאפשר העברת
> כמויות גדולות]{dir="rtl"} [יותר של נתונים ומבני נתונים מורכבים יותר
> בהשוואה לשיטות אחרות כמו]{dir="rtl"} GET.> ![](image30.png)


>נתון HTML Response הבא:
מה אפשר להגיד על בקשת הלקוח? (תמונה להמחשה)
א. הקובץ הועבר בהצלחה
ב. השרת לא הבין בקשת הלקוח
ג. השרת לא תומך בגרסת HTTP לפי בקשת הלקוח
**ד. השרת לא הצליח למצוא את הקובץ הרצוי.**
ה. אי אפשר לדעת מנתונים אלו.
> ![](image31.png)
>
> ![](image32.png)האם ניתן להשתמש בCOOKIES עם שיטת NON PERSISTENT?
> **א. אין שום בעיה, זה לא קשור אחד לשני.**
> ב. זה אפשרי מכיוון שבכל בקשה יש גם הדפדפן שמשתמשים בו, לכן השרת יוכל לשייך את זה לאותו משתמש.
> ג. זה אפשרי אך לא יביא שום תועלת כי באובייקט הבא זה כבר ישתנה.
> ד. זה בכלל לא אפשרי וקיים רק לעקוב אחרי משתמש בPERSISTENT ששם יש רצף פעולות.
> ה. זה אפשרי רק אם אין לCOOKIES תאריך פג תוקף.
>

>
> [ ]{dir="rtl"}
>
> אם החיבור בHTTP הוא מסוג PERSISTENT, האם עדיין צריכים COOKIES?
> הבמה שלכם... (שאלה למחשבה)
> > [עדיין אשתמש בכתובת ה]{dir="rtl"}IP [שנמצאת אצלי בקוקיז במקום לפנות
> לשרת ה]{dir="rtl"}DNS[.]{dir="rtl"}



>
> [תשובה: אם הלקוח לא אישר קוקיז, השרת יכול לעבוד עם קוקילס.]{dir="rtl"}
> coockless
>
> [ ]{dir="rtl"}
>
> ![](image34.png){width="5.358333333333333in"
> height="3.091666666666667in"}
>
> [שרת ה]{dir="rtl"}ROOT [מעביר אותי לשרתי]{dir="rtl"} TDL [שיפענחו לי
> את החלק האחרון של הכתובת.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> ![](image35.png){width="6.0in"
> height="2.029861111111111in"}
>
> [ ]{dir="rtl"}

[ ]{dir="rtl"}

> ![](Summeries/מבוא%20לרשתות%20מחשבים/media/media/image36.png){width="2.033333333333333in"
> height="0.875in"}
>
> ![](image37.png){width="6.0in"
> height="3.7395833333333335in"}
>
> [חישוב: לא בטוח נכון\$]{dir="rtl"}
>
> [רוצים להעביר את ה]{dir="rtl"}datagram [בעל 11760 בתים מ1 ל4.\
> נחשב את הזמן דרך צומת 2 ולצומת 3.\
> נעשה]{dir="rtl"} fregmentation[: 11740 בתים לאחר הוצאת
> ה]{dir="rtl"}header[.]{dir="rtl"}

-   [11 ה]{dir="rtl"} fregments [הראשונים יהיה עם 980 בתים ונוסיף עוד 20
    הידר, סה\"כ 1000 לכל אחד.]{dir="rtl"}

-   [מס\' 12 יהיה עם 740 בתים ונוסיף לו 20 להידר, סה\"כ 760.]{dir="rtl"}

> [מכיוון שבכל פעם ניתן לשלוח זוג חבילות, נחשב כמה זמן לוקח לזוג
> אחד:]{dir="rtl"}

-   [שנייה אחת להתפשטות (נתון)]{dir="rtl"}

-   [שנייה אחת לעיכוב שידור (גודל מסגרת 1000 חלקי קצב שידור
    1000).]{dir="rtl"}

-   [שנייה אחת להתפשטות]{dir="rtl"} ack[.]{dir="rtl"}

> [סה\"כ 3 שניות לזוג.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [בסך הכל יש 6 זוגות, לכן יקח 3\*6=18 יחידות זמן.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> ![](image38.png){width="6.0in"
> height="1.7381944444444444in"}
>
> [המסלול 1-3-4 נשאר כפי שהיה.]{dir="rtl"}
>
> [המסלול 1-2-4 התייעל ונהיה מהיר פי 2 מהקודם.]{dir="rtl"}
>
> [לכן במקום לחלק את 12 הפריימים לזוגות, נחלק לשלישיות. כשבצד אחד עובר
> פריים, בצד השני עוברים שני פריימים.]{dir="rtl"}
>
> [12/3=4 פריימים שעוברים ברשת יחד. לכל אחד לוקח 3 שניות פי
> שחישבנו.]{dir="rtl"}
>
> [4\*3=12, (נוסיף שנייה נוספת כדי לקבל]{dir="rtl"} ACK [על האחרון,
> סה\"כ 13)\$]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> ![](image39.png){width="5.975in" height="2.1in"}
>
> [ ]{dir="rtl"}

# [מצגת 3]{dir="rtl"} 

## [שיעור 4 - שכבת התעבורה]{dir="rtl"}

> ![Important](image2.png){width="0.16666666666666666in"
> height="0.16666666666666666in"}[ שכבת התעבורה - מספר 4:]{dir="rtl"}
>
> [כללי:]{dir="rtl"}

-   [שכבת]{dir="rtl"} [התעבורה]{dir="rtl"} [מטפלת]{dir="rtl"} [בתהליכים
    הלוגיים של התקשורת ומקבלת דרישות משכבת היישום העליונה]{dir="rtl"}
    [(5)]{dir="rtl"} [ומעבירה אותן לשכבת התקשורת התחתונה
    (3).]{dir="rtl"}

-   [ממומשת בעיקר במשתמשי הקצה ברשת.]{dir="rtl"}

-   [שכבה 3 לוקחת את הסגמנטים ומעבירה לשכבה הבאה,]{dir="rtl"} [ושכבה
    4]{dir="rtl"} [מטפלת בפרטיי המשלוח]{dir="rtl"} [ומעבירה אותם
    לכתובת]{dir="rtl"} [ה-]{dir="rtl"}IP [המתאימה]{dir="rtl"}. [תפקידה
    לדאוג שהבקשה שהגיעה משכבה 5, תגיע לצד השני (מהלקוח לשרת ומהשרת
    ללקוח).]{dir="rtl"}

-   [ההודעה שנשלחת בשכבה זו נקראת]{dir="rtl"} segments [(או]{dir="rtl"}
    udp packets [אם משתמשים בפרוטוקול זה).]{dir="rtl"}

> [ ]{dir="rtl"}

[פרוטוקולי שכבה 4:]{dir="rtl"}

-   [פרוטוקול]{dir="rtl"} UDP [- פרוטוקול חסר חיבור ובלתי
    אמין]{dir="rtl"}, [כלומר הוא אינו מבטיח שהנתונים יגיעו ליעדם באופן
    מסודר ובשלמות]{dir="rtl"}.

-   [פרוטוקולי]{dir="rtl"} RDT [- קבוצת טכניקות המבטיחות העברת נתונים
    אמינה ומוגנת מפני טעויות ברשתות מחשבים]{dir="rtl"}.[\
    פרוטוקול]{dir="rtl"} TCP [משתמש בטכניקות אלה, כדי להבטיח העברת
    נתונים אמינה.]{dir="rtl"}

> **[:]{dir="rtl"}RFC [מסמך]{dir="rtl"}**
>
> [מסמך שפורסם על ידי ה]{dir="rtl"}-Internet Engineering Task Force
> (IETF) [המתאר היבטים שונים של האינטרנט, כולל פרוטוקולים, נהלים
> וטכנולוגיות]{dir="rtl"}. RFCs [הם]{dir="rtl"} [מסמכים פורמליים
> המגדירים את המפרטים של פרוטוקול או טכנולוגיה מסוימת, והם
> נכתבו]{dir="rtl"} [בדרך כלל על ידי מומחים בתחום שתרמו לפיתוח
> הטכנולוגיה]{dir="rtl"}.[\
> משמש בעיקר מפתחי]{dir="rtl"} [תוכנה, מנהלי רשת ואחרים המעורבים בתכנון
> והטמעה של טכנולוגיות אינטרנט.]{dir="rtl"}

### [מקטעים -]{dir="rtl"} segments[:]{dir="rtl"}

-   [שכבה 5 שולחת נתונים (בקשת]{dir="rtl"} get [של דף אינטרנט,
    למשל).]{dir="rtl"}

-   [לשולח יש קובץ ענק לשלוח, לכן בשכבה 4 מתבצעת חלוקה לסגמנטים (יחידות
    קטנות של נתונים), באמצעות הפרוטוקולים]{dir="rtl"} TCP
    [או]{dir="rtl"} UDP[.]{dir="rtl"}

-   [בפרוטוקול ה]{dir="rtl"}TCP [למשל, ממלאים את פרטי המשלוח ושולחים
    לכתובת ה]{dir="rtl"}IP [המיוצגת בשכבה 3.]{dir="rtl"}

-   [הסגמנט עובר לשכבת הרשת 3. הפירוק מתרחש מהסיבה שיש הבדל בין המהירות
    שאני יכול להוריד (רוחב הפס שלי), לבין מהירות השרת שממנו ביקשתי
    חבילה. לכן החבילה מתפרקת לחלקים קטנים שאני יכול לקבל מהר
    יותר.]{dir="rtl"}

-   [לאחר מכן, הסיגמנטים מורכבים בחזרה לחבילה אחת.]{dir="rtl"}

> [\*ב]{dir="rtl"}UDP [לא יועברו סיגמנטים, אלא יחידות]{dir="rtl"}
> datagram [עם פחות מנגנונים מאשר]{dir="rtl"} TCP[, לכן משמש בד\"כ
> תוכניות \"זמן אמת\".]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [הסבר:]{dir="rtl"}
>
> [תהליך הסגמנטציה והרכבה מחדש -]{dir="rtl"} [טכניקת פירוק והרכבה של
> בלוקים גדולים של נתונים]{dir="rtl"} [למקטעים,]{dir="rtl"} [ואז להרכיב
> אותם מחדש בקצה המקבל]{dir="rtl"}.
>
> [ ]{dir="rtl"}

-   **[אצל השולח]{dir="rtl"}**, [הנתונים מחולקים למקטעים
    (]{dir="rtl"}segments[)]{dir="rtl"} [קטנים יותר.]{dir="rtl"}
    [הנתונים ממוספרים בסדר עולה, וזה מבטיח שכל]{dir="rtl"}
    [הסיגמנטים]{dir="rtl"} [מועברים]{dir="rtl"} [בסדר הנכון וניתן
    להרכיבם מחדש כראוי]{dir="rtl"} [**אצל המקבל**.]{dir="rtl"} [לכל קטע
    מוקצה גם מספר אישור (]{dir="rtl"}ACK[)]{dir="rtl"} [כדי לאשר שהוא
    הגיע ליעד באופן תקין.]{dir="rtl"}

-   [**אצל המקבל**,]{dir="rtl"} [המקטעים הבודדים מורכבים מחדש להודעה
    המקורית באמצעות]{dir="rtl"} [מספרי הרצף (]{dir="rtl"}sequence
    numbers[, בשיעור 5)]{dir="rtl"}. [ברגע שכל]{dir="rtl"}
    [הסיגמנטים]{dir="rtl"} [מתקבלים]{dir="rtl"} [ומורכבים מחדש
    כהלכה]{dir="rtl"}, [המקבל]{dir="rtl"} [המשתמש בשירותי]{dir="rtl"}
    TCP[, שולח אישור מסירה.]{dir="rtl"}

-   [על ידי פירוק הנתונים]{dir="rtl"} [לסיגמנטים]{dir="rtl"} [קטנים יותר
    והקצאת מספרי רצף ואישור, פילוח והרכבה מחדש]{dir="rtl"} [מסייעים
    להבטיח את השלמות והאמינות של העברת הנתונים, אפילו ברשתות
    לא]{dir="rtl"} [אמינות או]{dir="rtl"} [עמוסות]{dir="rtl"}.

> [ ]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [[מושג שני -]{dir="rtl"} Multiplexing & Demultiplexing[:
> ]{dir="rtl"}]{.underline}

-   **Mux**[: ריבוי - פעולת שליחת הנתונים ממספר אפליקציות שונות על אותו
    התווך, מבלי שהמידע יתערבב. שכבת הרשת דואגת לכך ע\"י הצמדת מידע זיהוי
    לכל חבילה שעוברת ברשת. המידע הזה נמצא בתוך הסוקט.]{dir="rtl"}

> [ ]{dir="rtl"}
>
> [החסרון:]{dir="rtl"}
>
> [מכיוון שזה אותו חוט, החבילה שנועדה למחשב מסויים, מגיעה גם למחשב אחר
> המחובר לאותו החוט, למרות שלא התכוונתי לשלוח אליה.]{dir="rtl"}
>
> wireshark []{dir="rtl"} [יכול ללכוד את כל החבילות המועברות ברשת,
> כולל]{dir="rtl"} [אלה שאינן מיועדות למחשב שלי, אך עברו על אותו תווך
> (חוטי או אלחוטי).]{dir="rtl"}
>
> [הנתב הוא סוג של מחשב, שמסתכל על כתובת ה]{dir="rtl"}IP [כדי לדעת לאיזה
> מחשב לשלוח את החבילה.\
> ברגע שהחבילה מגיעה לכרטיס הרשת שלי, הוא ממיר את כתובת ה]{dir="rtl"}IP
> [לכתובת חומרה, ומבחין שזו לא כתובת החומרה שלי ולכן זורק
> לפח.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [\*יכולה להיות יותר מכתובת]{dir="rtl"} IP [אחת למחשב, רק כדאי שלא תהיה
> התנגשות.]{dir="rtl"}
>
> )[זה שימושי בעיקר לשרתים שמספקים שירות למספר רב של משתמשים, אם
> כתובת]{dir="rtl"} IP [אחת מותקפת או נפגעת, השרת עדיין]{dir="rtl"}
> [יכול לתפקד).]{dir="rtl"}
>
> [ ]{dir="rtl"}

-   **Demux**[: חילוץ - פעולת חילוץ הנתונים שהועברו אצל המקבל על פי מידע
    הסוקט, כך שכל אפליקצייה מקבלת את המידע אליו חיכתה.]{dir="rtl"}

> [ ]{dir="rtl"}

### [ההבדלים בין]{dir="rtl"} TCP [ל]{dir="rtl"}UDP [בתהליך העברת המנות:]{dir="rtl"}

-   UDP [תומכת בשליחת חבילות רבות על אותו הסוקט (עם אותו היעד), אך
    מיישומים שונים. זה מתאפשר מכיוון שב]{dir="rtl"}UDP [לא נוצר חיבור
    (לא מוקמת שיחה) בין האפליקציה לשרת, אלא מתבצעת שליחת נתונים
    בודדת.]{dir="rtl"}

    -   [זה מצוין לשרת]{dir="rtl"} DNS[, מכיוון]{dir="rtl"} [שכולם
        יכולים לשלוח אליו בקשות.]{dir="rtl"} [במידה והשרת לא יכול לקבל,
        סביר להניח שהשולח יבין וישלח שוב]{dir="rtl"} [מאוחר
        יותר.]{dir="rtl"}

-   [לעומת זאת, ב]{dir="rtl"}TCP [אין תמיכה בשליחת חבילות רבות, מכיוון
    שנדרש]{dir="rtl"} **[יצירת חיבור]{dir="rtl"}** [(הקמת שיחה) לפני
    שניתן]{dir="rtl"} [**לשלוח מנות כדי לוודא שהסרבר פנוי**,]{dir="rtl"}
    [ומנות ממקורות שונים חייבות]{dir="rtl"} [לעבור]{dir="rtl"}
    [בסוקטים]{dir="rtl"} [שונים]{dir="rtl"} [בסרבר. לכן שרת]{dir="rtl"}
    google [למשל, המשתמש בגרסה]{dir="rtl"} HTTP/2 [צריך להחזיר הרבה מאוד
    חיבורים (סוקטים).\
    (בגרסה 3 יעשה שימוש ב]{dir="rtl"}UDP [במקום ב]{dir="rtl"} TCP[,
    בעיקר כדי למנוע צורך זה).]{dir="rtl"}

> [ ]{dir="rtl"}
>
> [\*פקודת]{dir="rtl"} netstat -a-b [: מציגה]{dir="rtl"} [את כל חיבורי
> הרשת]{dir="rtl"} [הפעילים. מידע זה יכול]{dir="rtl"} [לסייע בזיהוי
> ניסיונות גישה לא מורשית או זיהומים של תוכנות זדוניות
> במחשב]{dir="rtl"}.
>
> [ ]{dir="rtl"}
>
> [[פורטים]{dir="rtl"} [מקובלים]{dir="rtl"}]{.underline}[:]{dir="rtl"}
>
> [עד פורט 1,024 הפורטים הם ידועים.]{dir="rtl"}
>
> [עד 49,151 אלה פורטים שמורים לארגונים מסויימים.]{dir="rtl"}
>
> [עד 65,535 אלה פורטים פרטיים.]{dir="rtl"}
>
> [מכיוון שכל אפליקצייה שעל המחשב משתמשת בפורט מיוחד לה, מערכות הפעלה
> מגבילות את מספר]{dir="rtl"} [הפורטים]{dir="rtl"} [הפתוחים]{dir="rtl"}
> [ל-15,000,]{dir="rtl"} [כדי]{dir="rtl"} [להימנע מגישה]{dir="rtl"}
> [לפורטים שמורים או פרטיים.]{dir="rtl"}
>
> \[::1\] [מייצג את פורט 8.]{dir="rtl"}
>
> [שווה ערך ל:]{dir="rtl"} \[0000:0000:1000\]

-   [ב]{dir="rtl"}TCP[, אני צריך את פורט השולח כדי ששרת היעד ידע לאן
    להחזיר את התשובה]{dir="rtl"}.

> [ ]{dir="rtl"}

### [הרחבה - פרוטוקול]{dir="rtl"} UDP[:]{dir="rtl"}

-   UDP [- פרוטוקול בלי תוספות. המינימום שאני צריך כדי לשלוח חבילה לצד
    השני.]{dir="rtl"}

> [אין בקרת עומסים - יש מנגנון הצלה של הרשת של בקרת עומסים ואוטומטית אני
> מוריד את קצב השידור שלי.]{dir="rtl"} UDP [לא יודע שיש עומס ולכן הוא זה
> שעלול להפיל את הרשת.]{dir="rtl"}
>
> UDP [יכול לעבוד גם כשהרשת לקראת קריסה.]{dir="rtl"}\
> [ ]{dir="rtl"}
>
> [מי משתמש ב]{dir="rtl"}UDP[? למשל: שרת]{dir="rtl"} DNS[,]{dir="rtl"}
> http/3[, שרת סרטים. במהלך צפייה בסרט אין בעיה שיאבדו חבילות. גם אם
> חבילה אחת תאבד, לא ירגישו זאת. שרת]{dir="rtl"} DNS [מעדיף יעילות,
> ויודע שהמשתמש ינסה לגשת שוב כשהעומס ברשת יפחת.]{dir="rtl"}
>
> [אם רוצים שליחה אמינה עם]{dir="rtl"} UDP[, אז משתמשים במנגנונים
> שבשכבות אחרות.]{dir="rtl"}
>
> [עבור בקרת עומסים, פיתחו פרוטוקול חדש בשם]{dir="rtl"} quick udp
> [שמתבצע בין שכבה 4 ו5, אמנם לא משתמשים בו עדיין כי הדפדפנים לא מכירים
> בו.]{dir="rtl"}
>
> [ ]{dir="rtl"}

-   [ב]{dir="rtl"}TCP[, מערכת ההפעלה לא שולחת את הסיגמנטים לצד השני עד
    שלא התווספו כל הסיגמנטים, ויחד היא שולחת אותם לצד השני.]{dir="rtl"}

> [ ]{dir="rtl"}
>
> [Checksum]{.underline} [- בדיקה האם התחלפו ביטים. נועד לבדיקה האם המון
> ביטים התחלפו. אם ביט אחד או 2 התחלפו, לא אדע ולכן במקרים כאלה לא אשתמש
> ב]{dir="rtl"}UDP[.]{dir="rtl"}
>
> [המקבל מקבל את כל הנתונים חוץ מהצ\'קסם. בהעברה תקינה, צריך שהצ\'קסם של
> השולח והמקבל יהיו שווים.]{dir="rtl"}
>
> \*[צריך לדעת לחשב]{dir="rtl"} checksum[.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [עקרונות -]{dir="rtl"} principles[:]{dir="rtl"}
>
> [הכללים הבסיסיים המנחים את]{dir="rtl"} [התכנון והתפעול של פרוטוקולי
> רשת. למשל]{dir="rtl"} [עקרון המהימנות]{dir="rtl"}.
>
> [ ]{dir="rtl"}

### [פרוטוקולי]{dir="rtl"} RDT[:]{dir="rtl"} 

> [פרוטוקול]{dir="rtl"} sliding window[(חלון הזזה), המאפשרים העברת
> נתונים]{dir="rtl"} [אמינה.]{dir="rtl"}
>
> [אם שכבה צריכה להבטיח אמינות ואינה יכולה לסמוך על השכבה
> הבאה]{dir="rtl"} [שתטפל בה, היא עשויה להשתמש בפרוטוקול הכולל אישור
> מסירה, הידוע גם בשם פרוטוקול]{dir="rtl"} RDT[.]{dir="rtl"}\
> [ ]{dir="rtl"}
>
> [[עקרונות כלליים של פרוטוקולי]{dir="rtl"}
> RDT[:]{dir="rtl"}]{.underline}

-   **[השולח]{dir="rtl"}** [מחלק את הנתונים למקטעים
    (]{dir="rtl"}segments[) קטנים יותר, מוסיף קודי זיהוי ותיקון שגיאות
    (]{dir="rtl"}Acknowledment number[)]{dir="rtl"} [לכל
    מקטע]{dir="rtl"} [ושולח אותם למקלט]{dir="rtl"}.

-   **[המקבל]{dir="rtl"}** [בודק כל מקטע עבור שגיאות באמצעות קודי זיהוי
    השגיאות]{dir="rtl"} [ומבקש מ**השולח**]{dir="rtl"} [לשדר מחדש כל מקטע
    שיש בו שגיאות]{dir="rtl"}.

> [ ]{dir="rtl"}
>
> [[תכונות פרוטוקולי]{dir="rtl"} RDT[:]{dir="rtl"}]{.underline}

-   **Timeout** [- **השולח**]{dir="rtl"} [מצפה]{dir="rtl"} [לתגובה תוך
    פרק זמן מסוים לאחר שליחת חבילה, כדי]{dir="rtl"} [להבטיח שחבילה או
    הודעה נמסרת בתוך פרק זמן מסוים]{dir="rtl"}. **[השולח]{dir="rtl"}**
    [מגדיר ערך זמן קצוב כאשר הוא שולח חבילה, ואם]{dir="rtl"}
    **[השולח]{dir="rtl"}** [לא מקבל אישור]{dir="rtl"} (ACK)
    **[מהמקבל]{dir="rtl"}** [בתוך פרק זמן זה, הוא מניח שהחבילה אבדה
    ומשדר אותה מחדש.]{dir="rtl"}\
    \
    [הטיימר משמש לטיפול בתרחישים שבהם האישור אובד או מתעכב, ומבטיח
    שהשולח ישדר מחדש את החבילה במידת הצורך.]{dir="rtl"}

    -   [דוגמא מהמציאות: איש ואשתו, כאשר הבעל יוצא מהבית הוא מעדכן אותה
        מתי הוא יחזור. האישה מחכה זמן זה, ואם הוא נגמר ועדיין בעלה לא
        חזר, היא מצלצלת אליו. הזמן שהאישה המתינה, זה
        ה]{dir="rtl"}timeout[.]{dir="rtl"}

-   **Acknowledgment messages** [- הודעות]{dir="rtl"} [שנשלחו על ידי
    המקבל לשולח כדי לאשר כי חבילה התקבלה בהצלחה. השולח ממתין]{dir="rtl"}
    [ל]{dir="rtl"}-ACK [לפני שליחת החבילה הבאה. אם]{dir="rtl"} ACK [לא
    מתקבל תוך פרק זמן מסוים, השולח]{dir="rtl"} [מניח שהחבילה אבדה ומשדר
    אותה מחדש]{dir="rtl"}.

> [מספר ה]{dir="rtl"}ack [תמיד מסמל את החבילה הבאה שמצופה מהצד השני.\
> הסיבה לכך, היא כמו במקרה הבא: אם הגיעו החבילות 0,1,2 וארצה לסמן שכולם
> הגיעו, אז בהודעת האישור ארשום את מספר הרצף המצופה הבא, כלומר
> 3.]{dir="rtl"}
>
> Frame messages [- הודעות מסגרת, הן]{dir="rtl"} [יחידות]{dir="rtl"}
> [נתונים הנשלחות בין השולח למקבל.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [סוגים של פרוטוקולי]{dir="rtl"} RDT[:]{dir="rtl"}

-   [stop and wait]{.underline} [-\
    פרוטוקול]{dir="rtl"} RDT [פשוט,]{dir="rtl"} [ששולח חבילה אחת בכל פעם
    ומחכה לאישור לפני]{dir="rtl"} [שליחת החבילה הבאה]{dir="rtl"}.
    [הוא]{dir="rtl"} [קל ליישום,]{dir="rtl"} [אך]{dir="rtl"} [לא
    מאוד]{dir="rtl"} [יעיל]{dir="rtl"}.

> [יש רק מספר רצף של סיביות אחד שמרמז שגם לשולח וגם למקלט יש מאגר עבור
> מסגרת או חבילה אחת בלבד.]{dir="rtl"}

-   [השולח]{dir="rtl"} [משדר]{dir="rtl"} [מסגרת אחת]{dir="rtl"} [בכל פעם
    ומחכה ל]{dir="rtl"}-ACK [לפני שליחת המסגרת הבאה]{dir="rtl"}.

-   [לאחר שהשולח שולח]{dir="rtl"} frame[,]{dir="rtl"} [הוא
    מפעיל]{dir="rtl"} [טיימר]{dir="rtl"}.

-   [אם]{dir="rtl"} ACK [לא מתקבל לפני פקיעת הטיימר, השולח מניח
    שהמסגרת]{dir="rtl"} [אבדה ומשדר אותה מחדש]{dir="rtl"}.

> ![Lightbox](Summeries/מבוא%20לרשתות%20מחשבים/media/media/image40.png){width="3.925in"
> height="4.075in"}

-   [השולח מפעיל]{dir="rtl"} timeout [על כל מסגרת.]{dir="rtl"}

-   [כאשר]{dir="rtl"} Frame 0 [לא נשלח, הוא ישלח מחדש לאחר שיעבור
    ה]{dir="rtl"}timeout [(הזמן שאמור להגיע]{dir="rtl"} ack[, עם עוד
    תוספת קטנה בשביל עיכובים).]{dir="rtl"}

-   [כאשר]{dir="rtl"} Ack 0 [לא הגיע, השולח חושב שהמסגרת שהוא שלח, לא
    הגיעה. לכן יבצע שליחה מחדש עבור אותה מסגרת.]{dir="rtl"}

> [ ]{dir="rtl"}
>
> [יתרונות:]{dir="rtl"}

-   [פשוט ליישום ומבטיח שהמנות מתקבלות לפי הסדר.]{dir="rtl"}

-   [דורש חומרה פשוטה יותר, חלון המחזיק מסגרת אחת בלבד.\
     ]{dir="rtl"}

> [חסרונות:]{dir="rtl"}

-   [יש לו ביצועים]{dir="rtl"} [נמוכים -]{dir="rtl"} [מתי אשלח את המסגרת
    הבאה? רק אחרי שאקבל]{dir="rtl"} ack[. פוגע ברציפות התקשורת.\
     ]{dir="rtl"}

> [שאלה למחשבה:]{dir="rtl"}
>
> [אם בשיטה זו, שולחים חבילה אחת בכל פעם, לכאורה אין צורך
> ב]{dir="rtl"}sequence number[?]{dir="rtl"}
>
> [תשובה:]{dir="rtl"}
>
> [עיקר השימוש שלו הוא לאפשר מסירה מסודרת של מקטעי נתונים.]{dir="rtl"}
>
> [עיקר השימוש הוא במיתוג מנות, שאני מעביר את החבילות מצומת לצומת אחרת
> ברשת, ויכול להיות שחבילה אחת תגיע אחרי חבילה אחרת ברשת.]{dir="rtl"}
>
> [כאן אין בעיה שהסדר ישתנה, אמנם יש שימושים נוספים
> ל]{dir="rtl"}sequence number[, לדעת האם חבילה אבדה או
> שוכפלה.]{dir="rtl"}
>
> [ ]{dir="rtl"}

-   [Go Back-n]{.underline} [-\
    זהו פרוטוקול]{dir="rtl"} RDT [מורכב יותר]{dir="rtl"} [המאפשר שליחת
    מנות מרובות לפני המתנה לאישור. עובד על עקרון]{dir="rtl"}piplined
    [,]{dir="rtl"} [המאפשר]{dir="rtl"} [שליחת]{dir="rtl"} n [מסגרות בכל
    פעם, לפני שמצפים לאישור מהמקבל.]{dir="rtl"}

    -   [השולח שולח מספר מסגרות ביחד, כגודל החלון.]{dir="rtl"}

    -   [גודל החלון של המקבל, הוא תמיד 1 (שולח]{dir="rtl"} ack [לאחר כל
        מסגרת).]{dir="rtl"}

    -   [לאחר שליחת מספר פריימים,]{dir="rtl"} [השולח]{dir="rtl"} [מפעיל
        טיימר עבור מסגרת זו]{dir="rtl"}.

    -   [המקבל]{dir="rtl"} [שולח הודעת]{dir="rtl"} ACK [עבור]{dir="rtl"}
        [כל מסגרת שהוא מקבל]{dir="rtl"}.

    -   [אם השולח לא מקבל את האישור, זה מוביל לשידור חוזר של כל המסגרות
        הנוכחיות.]{dir="rtl"}

![](image41.png){width="5.166666666666667in"
height="3.191666666666667in"}

-   [במקרה זה שגודל החלון הוא 4, נשיב לב שנמצאות מספר חבילות שעדיין בתוך
    הערוץ ולא הגיעו ליעדן.]{dir="rtl"}

-   [השולח יכול לשלוח הרבה חבילות לפני שמקבל]{dir="rtl"}
    ACK[.]{dir="rtl"}

> [ ]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [יתרונות:]{dir="rtl"}

-   [ביצועים טובים]{dir="rtl"} [יותר מאשר]{dir="rtl"} stop&wait
    [לעיכובים ארוכים יותר, מכיוון שהוא מאפשר שליחת מנות]{dir="rtl"}
    [מרובות מבלי להמתין לאישור.]{dir="rtl"}

> *[ ]{dir="rtl"}*
>
> [חסרונות:]{dir="rtl"}

-   [יש לו]{dir="rtl"} [עלות]{dir="rtl"} [גבוהה יותר]{dir="rtl"}

-   [יכול לגרום לבזבוז רוחב פס]{dir="rtl"} [כדי לשלוח מנות רבות
    מחדש.]{dir="rtl"}

-   [עיכוב משמעותי כתוצאה מהעברת כל הנתונים מחדש. (ניתן להתגבר ע\"י
    שימוש במנגנון השלישי).]{dir="rtl"}

-   [אובדן מנות: אם השולח לא מקבל]{dir="rtl"} ack[, ישלח
    מחדש.]{dir="rtl"}

> [עיכוב ה]{dir="rtl"}ack [מעבר ל]{dir="rtl"}timeout [של החבילה, גם
> יגרום לשליחה מחדש.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> **[בעיית העותק הכפול:]{dir="rtl"}**
>
> [בעיה זו נוצרת כתוצאה משליחת מסגרת מיותרת. איך המקבל ידע האם לשמור את
> החבילה הכפולה או לזרוק אותה? ע\"י סיבית מספר הרצף, 0 או 1.]{dir="rtl"}
>
> [ע\"י קבלה מתמשכת של מנות עם אותו מספר רצף, כגון 0 ואחריו 0, המקבל ידע
> שהמסגרת השניה היא כפיל. אך אם יקבל מסגרות עם מספרי רצף שונים, כגון
> קבלת 0 ואחריו 1, זה מסמל שהמקלט קיבל שתי מנות נפרדות.]{dir="rtl"}
>
> [מספר הרצף מסייע בשמירה על הסדר והשלמות של החבילות המועברות. הוא מאפשר
> למקלט לזהות מנות כפולות ולטפל בהן בהתאם, ומבטיח שהנתונים מתקבלים בצורה
> נכונה ללא שכפול.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [ ]{dir="rtl"}

-   [Selective Repeat RDT[:]{dir="rtl"}]{.underline}

> \"[חזרה סלקטיבית]{dir="rtl"}\"[,]{dir="rtl"} [זוהי גרסה של
> פרוטוקול]{dir="rtl"} Go-Back-N, [שבו השולח רק משדר מחדש את החבילה
> שאבדה, במקום]{dir="rtl"} [לשדר מחדש את כל החבילות]{dir="rtl"}
> [שאחריה.]{dir="rtl"}
>
> [השולח]{dir="rtl"} [משדר]{dir="rtl"} [מספר מנות בבת אחת
> וממתין]{dir="rtl"} [לאישורים]{dir="rtl"} (ACKs) [מהמקבל. אם השולח לא
> מקבל]{dir="rtl"} ACK [עבור חבילה, הוא משדר מחדש רק את]{dir="rtl"}
> [החבילה הזו, ולא את כל החבילות מאותה חבילה ואילך]{dir="rtl"}.

-   [אני מבקש שליחה חוזרת כאשר לא הגיעה חבילה.]{dir="rtl"}

-   [המקבל מאשר את כל החבילות שהגיעו אליו.]{dir="rtl"}

-   [אם על 2 לא קיבלתי אישור למשל, אז אשדר מחדש רק את 2.]{dir="rtl"}

> ![](Summeries/מבוא%20לרשתות%20מחשבים/media/media/image42.png){width="4.633333333333334in"
> height="2.658333333333333in"}

-   [לפני שה]{dir="rtl"}sender [שולח חבילה, הוא מפעיל]{dir="rtl"}
    timeout [כדי לדעת מה לעשות כאשר לא התקבל]{dir="rtl"} ack [על חבילה
    שהוא שלח.]{dir="rtl"}

-   [חלון השליחה כעת הוא 4. בכל פעם שה]{dir="rtl"} sender
    [מקבל]{dir="rtl"} ack[, הוא מקדם את גבולות החלון ב1.]{dir="rtl"}

-   [לאחר שאושרו חבילות 0 ו1, ה]{dir="rtl"}sender [ממתין לאישור על
    2.]{dir="rtl"}

> [הוא מקבל רק על 3, לכן לא מקדם את החלון כדי לשלוח שוב, ובנתיים ממתין
> שיעבור ה]{dir="rtl"}timeout [כדי לשלוח שוב את חבילה 2.\
>  ]{dir="rtl"}
>
> [יתרונות:]{dir="rtl"}

-   [יעיל מאוד ברשתות לא אמינות, מפני שחוסך שליחה של חבילות
    מיותרת.]{dir="rtl"}

-   [שליחת מסגרות רציפה - ברגע שחבילה יוצאת מתחנת המוצא אל עבר היעד, אני
    יכול להעלות לשידור חבילה נוספת, מבלי לחכות
    ל]{dir="rtl"}ack[.]{dir="rtl"}

> [חסרונות:]{dir="rtl"}

-   [דורש ניהול מורכב יותר של מנות שעדיין לא אושרו.]{dir="rtl"}

> [צריך לאשר כל]{dir="rtl"} ACK [בנפרד - הסרבר]{dir="rtl"} [צריך לאשר
> בנפרד כל חבילה שהתקבלה, מה שיכול לגרום ליותר אישורים שנשלחו
> בהשוואה]{dir="rtl"} [לפרוטוקולי]{dir="rtl"} RDT [אחרים]{dir="rtl"}.

-   [השולח]{dir="rtl"} [צריך לשמור על מאגר גדול יותר כדי לאחסן מנות לא
    מאושרות]{dir="rtl"} [עד שהן יאושרו, מה שיכול לצרוך יותר
    זיכרון.]{dir="rtl"}

> [\*(גורמים אלה יכולים להגביר]{dir="rtl"} [את]{dir="rtl"}
> [העלות]{dir="rtl"} [והמורכבות של הפרוטוקול בהשוואה לפרוטוקולים פשוטים
> יותר כמו]{dir="rtl"} stop&wait[.]{dir="rtl"}
>
> [עם זאת, היתרונות]{dir="rtl"} [שלו עולים על]{dir="rtl"} [החסרונות
> הפוטנציאליים הללו בתרחישי רשת מסוימים]{dir="rtl"}.[)]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [\*ישנם עוד סוגים רבים של פרוטוקולי]{dir="rtl"} RDT[.]{dir="rtl"}
>
> [הם]{dir="rtl"} [משמשים הן את]{dir="rtl"} TCP [והן את]{dir="rtl"} UDP
> []{dir="rtl"} [כדי]{dir="rtl"} [להבטיח מסירה אמינה של נתונים
> ברשת]{dir="rtl"}.\
> [(אמנם]{dir="rtl"} TCP [מספק]{dir="rtl"} [אמינות חזקה יותר
> מאשר]{dir="rtl"} UDP [).]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [[מנגנון]{dir="rtl"} pickipacking[: ]{dir="rtl"}]{.underline}
>
> [גיבוי הוא טכניקה המנצלת חילופי הודעות, על מנת לשלוח]{dir="rtl"}
> [בתוכן נתונים נוספים מבלי לשדר מחדש.]{dir="rtl"}
>
> [לדוגמה, בחיבור]{dir="rtl"} TCP, [ניתן להעביר נתונים
> מהשולח]{dir="rtl"} [ל]{dir="rtl"}-ACKs [שנשלחו על ידי המקלט כדי להפחית
> את מספר החבילות שיש לשדר]{dir="rtl"}.
>
> [אני שולח]{dir="rtl"} frame+ack [באותו הסגמנט.\
> לדוגמא: \"קיבלתי את ההודעה! נ.ב, יש לי משהו נוסף
> להגיד\...\".]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [יתרונות:]{dir="rtl"}

-   [מייעל את השימוש ברוחב הפס]{dir="rtl"} [בהעברת הנתונים.]{dir="rtl"}

-   [חוסך במספר השידורים.\
     ]{dir="rtl"}

> [חסרונות:]{dir="rtl"}

-   [יכול להכניס מורכבות מסוימת לתהליך העברת הנתונים]{dir="rtl"}.
    [לדוגמה, אם הודעות]{dir="rtl"} ACK [מרובות מוחזרות בתוך מסגרת נתונים
    אחת, זה יכול להיות]{dir="rtl"} [קשה לקבוע איזה]{dir="rtl"} ACK
    [מתאים לאיזה פלח של נתונים]{dir="rtl"}.

-   [יכול ליצור עיכובים בהעברת הודעות]{dir="rtl"} ACK, [מכיוון שהמקלט
    חייב]{dir="rtl"} [להמתין להזדמנות מתאימה להחזיר את ההודעה בתוך מסגרת
    נתונים]{dir="rtl"}.

> [ ]{dir="rtl"}

## [דוגמאות:]{dir="rtl"}

[דוגמא לפרוטוקול]{dir="rtl"} HTTP [המשתמש בשירותי]{dir="rtl"}
TCP[.]{dir="rtl"}

![](image43.png){width="6.0in" height="1.8in"}

> ![](image44.png){width="2.2416666666666667in"
> height="0.21666666666666667in"}

1.  [יציאת מקור -]{dir="rtl"} source port[:]{dir="rtl"} [מספר יציאה
    המשמש לזיהוי]{dir="rtl"} [היישום השולח, ונבחר באקראי על
    ידו]{dir="rtl"}.

2.  [יציאת יעד -]{dir="rtl"} destination port[:]{dir="rtl"} [מספר יציאה
    המשמש לזיהוי היישום המקבל.]{dir="rtl"}

[ ]{dir="rtl"}

1.  [אורך מקטע]{dir="rtl"} TCP [-]{dir="rtl"} segment[: מספר הבתים
    בקטע]{dir="rtl"} TCP [שמועבר]{dir="rtl"}.

> [ ]{dir="rtl"}

2.  [מספר רצף -]{dir="rtl"} sequence [:]{dir="rtl"} [משמש
    לזיהוי]{dir="rtl"} [ייחודי של כל בייט של נתונים המועבר
    בחיבור]{dir="rtl"} TCP[.]{dir="rtl"} [מספר הרצף]{dir="rtl"} [של
    הבייט]{dir="rtl"} [הראשון של הנתונים בקטע משמש כנקודת
    התחלה]{dir="rtl"} [למספר הבתים הבאים]{dir="rtl"}.

> [ ]{dir="rtl"}

3.  [מספר אישור -]{dir="rtl"} ACK[:]{dir="rtl"} [מספר שנשלח על ידי
    המכשיר המקבל כדי לאשר]{dir="rtl"} [קבלת נתונים. הוא מציין את מספר
    הרצף הבא שהמכשיר המקבל מצפה לקבל מהמכשיר]{dir="rtl"}
    [השולח]{dir="rtl"}.

> [ ]{dir="rtl"}
>
> [\*כותרות אלה מספקות מידע הנחוץ בפרוטוקול]{dir="rtl"} TCP [בשכבה
> 4.]{dir="rtl"}
>
> [הן מספקות]{dir="rtl"} [מידע על המקור והיעד של]{dir="rtl"} [הנתונים
> המועברים]{dir="rtl"}, [וכן]{dir="rtl"} [מידע בקרה המסייע להבטיח מסירה
> אמינה של נתונים]{dir="rtl"}.
>
> [ ]{dir="rtl"}
>
> [דוגמא לפרוטוקול]{dir="rtl"} DNS [המשתמש בשירותי]{dir="rtl"}
> UDP[:]{dir="rtl"}

![](image45.png){width="4.191666666666666in"
height="1.6333333333333333in"}

1.  Checksum[: שיטה המשמשת]{dir="rtl"} [בתקשורת רשת כדי לזהות שגיאות
    בנתונים המועברים. זה כולל אלגוריתם מתמטי]{dir="rtl"} [שמחשב ערך
    ייחודי על סמך הנתונים המועברים, שנשלח לאחר מכן יחד עם
    הנתונים]{dir="rtl"}. [לאחר מכן המקלט יכול לבצע את אותו חישוב על
    הנתונים שהתקבלו ולהשוות את]{dir="rtl"} [התוצאה עם סכום הבדיקה המשודר
    כדי לבדוק אם הנתונים נפגמו במהלך השידור]{dir="rtl"}.

> [ ]{dir="rtl"}

[שאלה למחשבה:]{dir="rtl"}

> [למדנו שבשירותי]{dir="rtl"} UDP[, אין מושג של הודעת אישור
> (]{dir="rtl"}ack messege[) לאשר שהחבילה התקבלה בהצלחה. מדוע בכל
> זאת]{dir="rtl"} UDP [משתמש ב]{dir="rtl"}source port [אם
> כך?]{dir="rtl"}

[תשובה:]{dir="rtl"}

> [יש צרכים נוספים ל]{dir="rtl"}source port [אצל]{dir="rtl"} UDP[, כגון
> לאפשר למספר יישומים]{dir="rtl"} [לשלוח חבילות לשרת, מבלי שהמנות שלהם
> יתערבבו]{dir="rtl"}.
>
> [[לדוגמה]{.underline}:]{dir="rtl"} [במקרה של]{dir="rtl"}
> [שרת]{dir="rtl"} DNS[, יישומים מרובים יכולים לשלוח אליו]{dir="rtl"}
> [נתונים]{dir="rtl"} [בו זמנית,]{dir="rtl"} [על]{dir="rtl"} [אותו חיבור
> רשת.]{dir="rtl"}

[הוא צריך לדעת את יציאת המקור של כל מנה על מנת שיוכל לשלוח
את]{dir="rtl"} [חבילת התגובה חזרה לאפליקציה הנכונה.]{dir="rtl"}