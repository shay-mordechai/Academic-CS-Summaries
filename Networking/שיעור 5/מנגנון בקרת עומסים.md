### [מנגנון -]{dir="rtl"} congestion control [(בקרת עומסים):]{dir="rtl"}

> [**מופעל ע\"י השולח**.\
> כאשר יש עומס ברשת, נתב עם מאגר מלא ישליך מנות נכנסות וישלח הודעת
> התראה, כגון \"]{dir="rtl"}DUP ACK[\" (אישור כפול). זה מודיע לשולח
> שהרשת צפופה ואינה יכולה להתמודד עם התעבורה הנכנסת.]{dir="rtl"}
>
> [בטכניקת \"בקרת גודש]{dir="rtl"} TCP[\". כאשר השולח מקבל אישורים
> כפולים (]{dir="rtl"}DUP ACKs[) או חווה פסק זמן, הוא מפרש אירועים אלו
> כאינדיקציה לעומס ברשת, כולל מנגנונים מתוחכמים]{dir="rtl"} [שעוזרים
> למנוע עומס ברשת ולהבטיח שהרשת מנוצלת ביעילות]{dir="rtl"}.\
> TCP [משתמש בשילוב של התחלה איטית, הימנעות מגודש ושידור חוזר/שחזור
> מהיר]{dir="rtl"} [כדי לשלוט בקצב שליחת הנתונים]{dir="rtl"}.
>
> [ ]{dir="rtl"}

-   [השולח מזהה אובדן מנות, בעקבות אי הגעה של]{dir="rtl"} ack\'s [מצד
    המקבל.\
    כאשר השולח לא מקבל]{dir="rtl"} ACK [תוך זמן סביר
    (]{dir="rtl"}timeout[), הוא מניח שהחבילה אבדה ומפעיל שידור חוזר של
    החבילה.]{dir="rtl"}

```{=html}
<!-- -->
```
-   [בהמשך נראה את מנגנון]{dir="rtl"} dupack [שמקצר את ההמתנה
    ל]{dir="rtl"}timeout[.]{dir="rtl"}

> [  ]{dir="rtl"}
>
> [באיזה קצב עליי לשלוח את החבילות הבאות?]{dir="rtl"}
>
> [כאשר יש עומס ברשת, אנחנו עדיין רוצים להמשיך כמה שיותר את שגרת
> הרשת.]{dir="rtl"}
>
> [איך נדע **מהו הקצב שלא יכביד על הרשת** במצבה כרגע?]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [השולח ישתמש באחד מ3 האלגוריתמים הבאים:]{dir="rtl"}

1.  [Tahoe algorithm]{.underline}[: ארד חזרה לקצב המינימלי בו
    התחלתי.]{dir="rtl"}

```{=html}
<!-- -->
```
1.  Slow start [- בתחילת ההעברה, השולח יעלה לאט לאט את קצב השידור. אם
    קיבלתי]{dir="rtl"} ack[, החלון שלי (]{dir="rtl"}MSS[) גדל
    ב1.]{dir="rtl"}

    [לאחר מכן אמשיך להעלות בצורה אקספוננציאלית כדי למצוא את הקצב הנכון
    מהר יותר.]{dir="rtl"}

    [כשאגיע לתקרת סף כלשהי שהגדרתי מראש (]{dir="rtl"}sssthresh[), אמשיך
    להעלות את קצב השידור, אך בקצב לינארי.]{dir="rtl"}

    [לאחר זיהוי אובדן מנות, חלון השולח \"יתאפס\" שוב ל1.]{dir="rtl"}

    [תחל עלייה אקספוננציאלית כנ\"ל, אך ה]{dir="rtl"}ssthresh [יהיה נמוך
    יותר הפעם.\
     ]{dir="rtl"}

> [האינדיקציה של]{dir="rtl"} Tahoe [לזיהוי עומס:]{dir="rtl"}

-   [שלחתי חבילה, אך לא התקבל עליה]{dir="rtl"} ack [בזמן סביר
    (]{dir="rtl"}timeout[).]{dir="rtl"}

-   [קבלת]{dir="rtl"} acks [כפולים, המראה שמשהו לא תקין
    בשליחה.]{dir="rtl"}

> [ ]{dir="rtl"}

2.  [[אלגוריתם]{dir="rtl"} Reno]{.underline} [- מבוסס על]{dir="rtl"}
    Tahoe[, עם מעט שיפורים כדי לזהות מוקדם יותר מהו גבול
    העומס.]{dir="rtl"}

    -   [כאשר השולח מזהה אובדן מנות, מקטין את גודל חלון הגודש שלו
        בחצי.]{dir="rtl"}

    -   [לאחר צמצום גודל חלון הגודש, השולח מגדיל את גודל חלון הגודש שלו
        בהדרגה, מה שמכונה \"הגדלה מתווספת\". השולח מגדיל את חלון הגודש
        בתוספת קטנה עבור כל חבילה שאושרה בהצלחה.\
         ]{dir="rtl"}

> [האינדיקציה של]{dir="rtl"} Reno [לזיהוי עומס:]{dir="rtl"}
>
> [כולל מנגנונים נוספים לזיהוי מוקדם של אובדן מנות:]{dir="rtl"}

-   [כאשר קיבלתי שלושה]{dir="rtl"} ACKs [כפולים עבור חבילה מסוימת, אניח
    שהחבילות הבאות אבדו וזה סימן לעומס.]{dir="rtl"}

> [לאחר זיהוי שלושה]{dir="rtl"} ACKs [כפולים, רינו מבצע שידור חוזר מהיר
> של החבילה החסרה מבלי לחכות לפסק זמן.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> ![](image56.png){width="3.6166666666666667in"
> height="2.2416666666666667in"}
>
> [ ]{dir="rtl"}

3.  [[שיטת]{dir="rtl"} AIMD]{.underline} [- מגדילים את הקצב כל פעם ב1,
    ומורידים בחלקי 2.]{dir="rtl"}

> [העלאה ב]{dir="rtl"}\'+\' [והורדה ב]{dir="rtl"}\'/\'[.]{dir="rtl"}
>
> [קצב לא סטטי אלא דינמי בהתאם לעומס הרשת.]{dir="rtl"}
>
> [כל עוד לא נתקעתי, אמשיך להעלות ב1.]{dir="rtl"}
>
> ![time ](image57.png){width="3.533333333333333in"
> height="2.1in"}
>
> [השימוש בכל מנגנון תלוי האם הרשת על סף קריסה או עובדת רוב הזמן ורק
> חבילה אחת אבדה.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [שיטת]{dir="rtl"} AIMD [זו השיטה שעובדת כיום.]{dir="rtl"}
>
> [(שיטה נוספת פופולרית זו]{dir="rtl"} CUBIC[)]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [אלגוריתמים אלו שואפים למצוא קצב שידור אופטימלי המונע עומס יתר על הרשת
> תוך מיקסום היעילות. השולח מגביר בהדרגה את קצב השידור במהלך שלב ההתחלה
> האיטית ולאחר מכן מתאים אותו בהתבסס על אותות גודש המתקבלים מהרשת (למשל,
> אובדן מנות, כפולות]{dir="rtl"} ACKs[) במהלך שלב הימנעות
> מגודש.]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [(\*בשנים קודמות בקורס היה יותר חומר על]{dir="rtl"} TCP [מאשר
> אצלנו.)]{dir="rtl"}
>
> [ ]{dir="rtl"}
>
> [שאלה למחשבה:]{dir="rtl"}
>
> [מדוע ב]{dir="rtl"}TCP [משתמשים גם בבקרת זרימה וגם בבקרת עומסים, אם
> שניהם משמשים לאותה המטרה - לווסת את העומס ברשת?]{dir="rtl"}
>
> [התשובה:]{dir="rtl"}
>
> [שניהם נחצים, כי בקרת זרימה מטפלת בעומס מצד המקבל, ובקרת עומסים בצד
> השולח.]{dir="rtl"}

-   [אם הייתה רק בקרת זרימה, אז השולח יתחיל לשדר מיד במהירות גבוהה,
    ויגרום למקבל מהר מאוד לעצור אותו ע\"י הקטנת החלון.]{dir="rtl"}

-   [אם הייתה רק בקרת עומסים, אז אמנם השולח היה מתחיל במהירות נמוכה ומאט
    כשמזהה עומס, אך כשיש המון משתמשים ששולחים לסרבר אחד, מיד יכולים
    לגרום לעומס יתר ברשת.]{dir="rtl"}

> [אפשר להגיש שיש פה אינטרסנטיות.]{dir="rtl"}

-   [המקבל דואג שלא יעמיסו עליו ע\"י הקטנת החלון.]{dir="rtl"}

-   [השולח דואג שלא יעצרו לו את השידור מהר מידיי.]{dir="rtl"}

> [דבר נוסף, בקרת עומסים מונעת את העומס לכתחילה מלהתרחש. אך זה לא מספיק
> במקרה שיש המון משתמשים שמשדרים יחד. אפילו אם הם ישדרו על מהירות
> מינימלית, זה יכול להביא לעומס. לכן צריך גם בקרת זרימה כדי לעצור את
> העומס בדיעבד, שכבר קרה.]{dir="rtl"}
>
> [ ]{dir="rtl"}
