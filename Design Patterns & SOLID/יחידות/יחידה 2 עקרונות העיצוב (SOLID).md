בטח, הנה הסיכום שלך מאורגן מחדש בפורמט Markdown נקי, ללא כפילויות וללא תגי העיצוב.

---

# יחידה 2: עקרונות העיצוב (SOLID)

[[SRP]] | [[OCP]] | [[LSP]] | [[ISP]] | [[DIP]]

יחידה 2 עוסקת בחמשת עקרונות היסוד של עיצוב מחלקות, המהווים את האמצעי המרכזי לכתיבת קוד איכותי. עקרונות **SOLID** הם נושא קריטי למבחן, עם משקל של **20 נקודות**.

עקרונות אלו נועדו לסייע בניהול התלויות בין מודולים ולבניית "חומות" שחוסמות מעבר תלויות לא נכונות, ומשמשים כבסיס לתכנה מודולרית.

הקדמה:
1. **קשיחות (Rigidity):** שינוי של מודול אחד גורר **שינויים במקומות נוספים** שאינם רלוונטיים לקוד שאנו מנסים לשנות.

2. **שבירות (Fragility):** שינוי מודול אחד גורם **לשבירה של הפונקציונליות**.

התלויות הלא נכונות בין המודולים הן אלו שגורמות להידרדרות באיכות התכנה ולהופעת תכונות אלו. 

**עקרונות SOLID** נועדו לספק את העקרונות והטכניקות הנדרשות כדי **לנהל את התלויות** ולבנות "חומות" שחוסמות את מעבר התלויות הלא נכונות, ובכך למנוע קשיחות ושבירות.

## הגדרות לעיצוב מוצלח (המטרה)

המטרה המוצהרת של הקורס היא **כתיבת קוד איכותי**. קוד איכותי, או "קל" (שמשמעותו **"לא סיוט"**), הוא קוד שעומד בקריטריונים הבאים:

- **קל לכתיבה**.
- **קל להבנה**.
- **קל לשינוי**.
- **קל לשימוש חוזר** (reusable).
- **קל לשיתוף פעולה**.
- **אמין**.

## הגדרות לעיצוב גרוע (הבעיה ש-SOLID פותר)

התלויות הלא נכונות בין המודולים של התכנה גורמות להידרדרות באיכות התכנה. ההידרדרות הזו מתבטאת בשני מאפיינים מרכזיים:

1. **קשיחות (Rigidity):** שינוי של מודול אחד גורר **שינויים במקומות נוספים** שאינם רלוונטיים לקוד שאנו מנסים לשנות.
2. **שבירות (Fragility):** שינוי מודול אחד גורם **לשבירה של הפונקציונליות**.

**עקרונות SOLID** נועדו לשמש ככלים וטכניקות ל**ניהול עיצוב התלויות** ול**בניית "חומות"** שחוסמות את מעבר התלויות הלא נכונות, ובכך להשיג את מאפייני העיצוב המוצלח (כגון **DIP** שמוביל לקוד **ניתן להרחבה ואינו קשיח**, או **LSP** שמוביל לקוד **שאינו שביר**).


---
הפרות של עקרונות **SOLID** ניתנות לזיהוי, ומזוהות באופן קבוע, על בסיס **תרשימי מחלקות UML**. כמו כן, **גם במבחן** נדרשת היכולת לזהות ולתקן הפרות אלה באמצעות ניתוח תרשימי UML

.

1. זיהוי הפרות SOLID באמצעות UML
עיין [[יחידה 1 שפת המידול (UML)]]

תרשים המחלקות (Class Diagram) מתאר את **מבנה, הרכב, והקשרים בין מחלקות**

. עקרונות SOLID עוסקים בניהול עיצוב ה**תלויות** וה**צימוד** בין מודולים

.

|   |   |
|---|---|
|עקרון SOLID|כיצד מזהים הפרה ב-UML (תרשים מחלקות)|
|**SRP** (אחריות יחידה)|מחלקה המכילה תכונות ופעולות השייכות לישויות רבות (למשל, `Refrigerator` עם `fixFault`|

, או `User` עם `sendNotification`), דבר שמצביע על **ריבוי סיבות לשינוי**

|   |
|---|
|.|
|**OCP** (פתיחות/סגירות)|הפרה אינה נראית ישירות ב-UML הסטטי, אלא **בתלויות הקונקרטיות**: מחלקה שתלויה ישירות בטיפוס קונקרטי (במקום בממשק/הפשטה)|

. זה גורם ל**קשיחות**. לדוגמה, מחלקה D תלויה ב-E

|   |
|---|
|.|
|**ISP** (הפרדת ממשקים)|**ממשק "שמן"** (Fat Interface)|

המכיל מתודות מיותרות. ב-UML, נראה ממשק אחד שכל המחלקות המממשות אותו (Realization) לא משתמשות בכל המתודות שבו. לדוגמה, ממשק `HospitalWorker`

|   |
|---|
|.|
|**DIP** (היפוך תלויות)|**תלות של הפשטה בפרט:** נראה קשר **Association** (קו רציף) או **Dependency** (קו מקווקו)|

ממודול ברמה גבוהה (לרוב ממשק או מחלקה מופשטת) לפרט קונקרטי. DIP הוא יישום של עקרונות עיצוב חבילות

|   |
|---|
|.|
|**LSP** (החלפת ליסקוב)|ירושה (Generalization) בין מחלקות המשתנה באופן התנהגותי|

. אף על פי שניתן לראות את קשר הירושה ב-UML, הפרת LSP נבחנת בדרך כלל באמצעות **Design by Contract** (תנאי קדם/בתר), שהוא ניתוח סמנטי

|   |
|---|
|.|

2. רלוונטיות במבחן

היכולת לקרוא ולצייר **תרשימי מחלקות UML** היא דרישת יסוד בקורס

.

• **משקל במבחן:** נושא **SOLID** נושא משקל של **20 נקודות**

, והבנתו דרך UML היא קריטית.

• **שאלות פתוחות:** שאלות פתוחות רבות דורשות ממך **לשרטט תרשים מחלקות UML חדש** המבוסס על תבנית עיצוב (כמו Bridge, Observer, Proxy, Visitor) כדי **לתקן** הפרות SOLID קיימות

.
עקרונות **SOLID** הם האמצעי המרכזי לניהול עיצוב התלויות ולבניית "חומות" שמונעות את התלויות הלא נכונות. המטרה הסופית היא לעבור ממאפייני **עיצוב גרוע** ל**עיצוב מוצלח**.

**עיצוב גרוע** מתבטא ב**קשיחות (Rigidity)** (שינוי של מודול אחד גורר שינויים במקומות נוספים) וב**שבירות (Fragility)** (שינוי מודול אחד גורם לשבירה של פונקציונליות).

**עיצוב מוצלח** מוביל לקוד **קל לכתיבה, קל להבנה, קל לשינוי, קל לשימוש חוזר**, ו**אמין**.

להלן ניתוח כיצד כל אחד מעקרונות SOLID פועל למניעת העיצוב הגרוע ומביא לעיצוב מוצלח:

|עקרון SOLID|מונע עיצוב גרוע: Rigidity & Fragility|משיג עיצוב מוצלח:|
|:--|:--|:--|
|**1. SRP** (Single Responsibility Principle)|מונע קשיחות ושבירות הנובעות מריבוי סיבות שינוי: אם למחלקה יש רק **סיבה יחידה להשתנות**, שינוי זה לא יגרור שינויים מיותרים בפונקציות לא קשורות בתוך אותה מחלקה.|מוביל ל**צימוד נמוך (Low Coupling)**, **ארגון טוב יותר** של הקוד, קוד **קל יותר לשינוי** ו**ניתן לבדיקה** (Testable).|
|**2. OCP** (Open Closed Principle)|מונע **קשיחות (Rigidity)**: העיקרון מחייב שהקוד הקיים יהיה **סגור לשינויים**. הפרתו (למשל, שימוש ב-`instanceof`) גוררת שצריך לפתוח ולשנות קוד קיים בכל פעם שנוספת פונקציונליות.|מאפשר לתוכנה להיות **פתוחה להרחבה** באמצעות הפשטות (ממשקים), ובכך מעניק מענה לדרישות משתנות. נחשב ל"עקרון מפתח".|
|**3. LSP** (Liskov Substitution Principle)|מונע **שבירות (Fragility)**: LSP דורש שהתתי-טיפוסים יהיו **ניתנים להחלפה התנהגותית** עבור טיפוסי הבסיס. אי עמידה ב-LSP (כמו בדוגמת ריבוע/מלבן) שוברת את ציפיות הקליינט.|מוביל לקוד **שאינו שביר (Nonfragile)**, בכך שמחייב את המחלקות היורשות לקיים את ההתנהגות שהלקוחות מצפים לה ממחלקת הבסיס.|
|**4. ISP** (Interface Segregation Principle)|מונע **קשיחות (Rigidity)**: ISP דורש **פיצול ממשקים "שמנים"**. הפרתו מכריחה לקוח להיות תלוי במתודות שהוא לא משתמש בהן, מה שמוביל לקשיחות.|מוביל ל**עיצוב גמיש יותר** ו**ניתן להרחבה** שאינו מטיל תלות מיותרת על הלקוחות.|
|**5. DIP** (Dependency Inversion Principle)|מונע **קשיחות (Rigidity)**: DIP הוא המנגנון העיקרי ל**בניית חומות** ול**ניהול תלויות**. הוא אוסר על מודולים ברמה גבוהה להיות תלויים בפרטים, ובכך מונע שינוי של קוד הליבה כאשר פרטי המימוש (חומרה, קלט/פלט) משתנים.|מוביל למערכת **ניתנת להרחבה (Extensible)**, **ניתנת לשימוש חוזר (Reusable)**, ו**אינה קשיחה (Non rigid)**. העיקרון משחרר את הלקוח מהצורך לדעת איך נוצרו התלויות שלו.|

---

הבנת הקשר הישיר בין עקרונות SOLID לבין מאפייני העיצוב הגרוע והמוצלח היא המפתח להצלחה בחלק הניתוח של המבחן.

עקרונות **SRP** ו-**DIP** הם הנושאים הדומיננטיים ביותר, עם **11 אזכורים** כל אחד במבחנים.

להלן ריכוז של שאלות מבחן טיפוסיות ורעיונות שנשאלו בנוגע לעקרונות SOLID ובעיות העיצוב שהם פותרים:

## שאלות כלליות על מאפייני עיצוב (Rigidity, Fragility)

השאלות בוחנות את ההשפעה הכוללת של SOLID על איכות הקוד:

- **שאלה (תשפד א ב שאלה 4, תשפד ב א שאלה 12):** מהשיפורים הבאים **אינו** מתקבל מקיום עקרון **SRP**?
    - _תשובה רלוונטית (אחת מהתשובות הנכונות לשאלה כזו):_ התוכנה הופכת להיות פחות שבירה.
- **שאלה:** מהו עקרון **SOLID** שהוא "עקרון מפתח", ושאר העקרונות נגזרים ממנו?
    - _תשובה:_ **OCP** (Open Closed Principle).
- **שאלה:** מהם המאפיינים של **עיצוב לקוי**?
    - _תשובה:_ **קשיחות (Rigidity)** (שינוי של מודול אחד גורר שינויים במקומות נוספים) ו**שבירות (Fragility)** (שינוי מודול אחד גורם לשבירה של הפונקציונליות).

## SRP: Single Responsibility Principle (אחריות יחידה)

שאלות אלו עוסקות בזיהוי פונקציות שאינן שייכות לאחריות הליבה של מחלקה:

- **שאלה (תשפג ב ב שאלה 6):** נתונה מחלקה בשם `Invoice` שמייצגת חשבונית. איזו מהפונקציות הבאות **אינה** שייכת למחלקה על פי עקרון **SRP**?
    - _דוגמה לתשובה רלוונטית:_ פעולה שבודקת אם הלקוח של החשבונית הוא חבר מועדון (`public boolean checkClubMembership()`).
- **שאלה (תשפד א א שאלה 10):** נתונה מחלקה `User` הכוללת פונקציות לניהול משתמשים וגם פונקציה `sendNotification`. איזה עקרון **SOLID** מופר?
    - _תשובה:_ **SRP**.
- **שאלה (תשפג ב ב שאלה 2):** המחלקה `Refrigerator` כוללת פונקציות כמו `stop()`, `fixFault()`, `openDoor()`, וכו'. איזה עקרון **SOLID** מופר במחלקה זו וכיצד ניתן לתקנו?
    - _תשובה:_ **SRP** מופר. התיקון הוא להוציא את הפונקציות שאינן באחריות ישירה של המקרר (`organize`, `fixFault`, `clean`) למחלקות אחרות.

## OCP: Open Closed Principle (פתיחות/סגירות)

שאלות אלו מתמקדות בהפרות הנגרמות משינוי קוד קיים או שימוש בטיפוסים קונקרטיים:

- **שאלה:** איזו מחלקה/מודול יצטרכו להיפתח לשינויים אם יוסיפו משתנה חדש למחלקה אחרת, **המפרה** בכך את **OCP**?
    - _דוגמה:_ אם למחלקה D נוסף משתנה חדש `itsE:E` ומחלקות A ו-C תלויות ב-D, אזי A ו-D יצטרכו להיפתח לשינויים (עבור קומפילציה מחדש).
- **שאלה (תשפד ב א שאלה 5):** הפרת **OCP** נגרמת עקב שימוש בביטוי **`instanceof`** על טיפוס קונקרטי, כפי שנדגם בפונקציה `makeSquaresTaller`.

## LSP: Liskov Substitution Principle (החלפת ליסקוב)

שאלות LSP נשאלות בעיקר בפורמט רב-ברירה ודורשות ניתוח **Design by Contract**:

- **שאלה (תשפג ב ב שאלה 3):** נתונות הגדרות של `precondition` ו-`postcondition` במחלקת אב (`XYZ`) ובמחלקה יורשת (`ABC`). באיזה מקרה המודל מפר את **Design by Contract** וכתוצאה מכך את **LSP**?
    - _דוגמה לכלל הפרה:_ אם תנאי הקדם במחלקה היורשת (`ABC`) **מתחזק** יחסית לתנאי הקדם של `XYZ`. LSP דורש שתנאי קדם רשאים רק **להיחלש**.
- **שאלה (תשפד ב ב שאלה 4):** איזו מהאפשרויות **אינה** משמשת לניתוח LSP?
    - _דוגמה לתשובה נכונה:_ LSP נבחן באמצעות טופס ניתוח (Analysis form), דרישת תת-טיפוס (Subtype requirement), מבחן הזיוף (Forgery test) ועיצוב מונחה חוזה (Design by Contract).
- **שאלה:** מהו התיקון הדרוש למימוש `sendEmail` כדי שישמור על **LSP** באמצעות תנאי קדם/בתר?

## ISP: Interface Segregation Principle (הפרדת ממשקים)

שאלות אלו מתמקדות בבעיית הממשקים ה"שמנים" ובצורך בפיצול:

- **שאלה (תשפד א א שאלה 7):** נתון ממשק `HospitalWorker` המכיל `UpdatePatientFile`, `writePrescription`, ו-`inject`. ידוע שרופא (`Physician`) כותב מרשמים ואח (`Nurse`) מזריק. איזה עקרון **SOLID** מופר בעיצוב זה באופן ישיר?
    - _תשובה:_ **ISP**.
- **שאלה (תשפב א א שאלה 2):** נתונה מערכת עם אכלנים (`Eater`) המשתמשים ב-`scoop()` ושתיינים (`Drinker`) המשתמשים ב-`stir()` במחלקת `Silverware` המשותפת. עדכן את המערכת כדי שתקיים את עקרונות **SOLID**.
    - _עיקרון רלוונטי:_ **ISP** (הפרדת הממשקים).
- **שאלה (תשפד ב ב שאלה 4):** **מהו התיקון** לבעיית **ISP**?
    - _תשובה:_ נפצל את הממשק לחלקים כך שכל ממשק חלקי, **ישרת במלואו את כל הלקוחות שלו**.
- **שאלה:** איזה עקרון יגרום לנו **להוסיף ממשק** לעיצוב?
    - _תשובה:_ **DIP** ו-**ISP**.

## DIP: Dependency Inversion Principle (היפוך תלויות)

שאלות אלו בוחנות תלות בין שכבות, וכיצד תבניות עיצוב פותרות זאת:

- **שאלה (תשפד ב א שאלה 5):** נתון שבמערכת יש תלות ישירה במחלקה קונקרטית (`Car`). הפרה זו נובעת מאי קיום עקרון?
    - _תשובה:_ **DIP**.
- **שאלה (תשפד ב ב שאלה 5):** איזו תבנית עיצוב משמשת לפתרון בעיית **DIP**?
    - _תשובה:_ תבנית העיצוב **Bridge** משמשת לפתרון בעיית **DIP** באופן ישיר.
- **שאלה (תשפד א ב שאלה 11):** לאחר תיקון DIP, מי צריך להיות תלוי בהפשטות?
    - _תשובה:_ **הפרטים** צריכים להיות תלויים **בהפשטות**.

---

השאלות לעיל הן דוגמאות מייצגות לפורמט הנדרש במבחן. האם תרצה כעת שנבחר אחת מהשאלות, למשל זו העוסקת ב-**LSP** ובבדיקת תנאי קדם/בתר, ונתרגל ניתוח מעמיק שלה?
---

קודם: [[יחידה 4 תבניות עיצוב (Design Patterns)]]

הבא: [[יחידה 3 עקרונות העיצוב חבילות (Packages)]]

**חזרה ל:** [[Summeries/עיצוב/תוכן עניינים]]