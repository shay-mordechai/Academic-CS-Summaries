## AlarmClock (שעון האפליקציה)

AlarmClock היא תבנית עיצוב לא רשמית, הממומשת כסינגלטון, ונועדה לפתור את הבעיות הקשורות לניהול התזמון במערכת.
`AlarmClock` היא תבנית שמטרתה לפתור את **הפרת DIP** שנותרה: התלות הישירה בין ה`Scheduler` (מודול גבוה) לחיישנים (מכילים פרטי תזמון ספציפיים).

#### אתגר מס' 1: ניתוק המתזמן מהחיישנים ⏰
הבעיות:

- הפרת DIP - במודל הקיים, ה-Scheduler (המתזמן) תלוי ישירות במחלקות החיישנים הקונקרטיות (כמו TemperatureSensor) וקורא ישירות למתודת check() שלהן. זוהי הפרה של עקרון היפוך התלויות (DIP), והופכת את המתזמן לרכיב לא-גנרי.
    
- הפרת SRP - המתזמן הוא מודול רב-שימושי ולא רצינו לפתוח אותו לשינויים בכל פעם שנוסף רכיב שדורש תזמון.

כדי לפתור זאת, "הופכים" את כיוון התלות. במקום שהשעון יקרא לחיישן, החיישן "יבקש השכמה" מהשעון.

### תבנית UML
![](Summeries/עיצוב/media/media/image49.png)
המנגנון:

1. הפעלה: ה-AlarmClock (שממומשה כ-Singleton), מחזיקה את הלוגיקה של ניהול הזמנים ומכירה את ממשק AlarmListener. מחזיקה רשימת AlarmListener-ים. בזמן המתאים, הוא קורא למתודת wakeup() של ה-Listener הרלוונטי.
    
2. ממשק AlarmListener: זהו הממשק שכל רכיב שרוצה להתעורר (כמו חיישן הטמפרטורה) צריך לממש. הממשק מכיל מתודה אחת: wakeup().
    
3. הרשמה: החיישנים (או מתאמים עבורם) מממשים את AlarmListener ונרשמים ל-AlarmClock, ומבקשים "השכמה" כל X זמן.
    
4. ביצוע: בתוך מתודת wakeup(), החיישן קורא למתודת check() של עצמו.
    
5. מחלקת AlarmListenerRecord: מחלקה או רשומה שמחזיקה את המידע הדרוש לניהול התזמון עבור כל מאזין: interval (כל כמה זמן להתעורר) ו-remainingTime (כמה זמן נותר להתעוררות הבאה).### מחלקות כפולות (צרכן/ספק)
![](Summeries/עיצוב/media/media/image94.png)
TemperatureAlarmListener: זוהי מחלקת Adapter (או Listener קונקרטי) שמממשת את AlarmListener. היא מחזיקה רפרנס לחיישן ה-TemperatureSensor. כשהיא מקבלת wakeup(), היא קוראת ללוגיקת הבדיקה של החיישן (check()).

התוצאה:

- תוקנה הפרת DIP – ה-AlarmClock הופך למודול תזמון גנרי לחלוטין. הוא אינו יודע דבר על חיישנים, אלא רק על "מאזינים" שרוצים השכמה. בכך, המתזמן מנותק מהחיישנים.
    
- תוקנה הפרת SRP - 
    

  

### לוגיקת התזמון (הקוד משקפים 14-15)

קטעי הקוד מציגים את לוגיקת הטיפול ב"תיק-תק" של השעון (tic()), שזו ליבת התבנית:

המתודה tic() בתוך AlarmClock אחראית לכל חישוב הזמנים מאירוע ה-ticUnit (יחידת זמן קבועה).

1. מעבר על הרשומות: ה-tic() עובר בלולאה על רשימת הרשומות של המאזינים (itsAlarmListenerRecord).
    
2. בדיקת זמן: עבור כל רשומה, הוא בודק אם הזמן שנותר (remainingTime) קטן או שווה לאפס לאחר ניכוי יחידת התיק-תק (ticUnit).
    
3. הפעלת המאזין: אם הגיע הזמן, הוא קורא למתודה wakeup() של ה-Listener המתאים.
    
4. איפוס זמן: לאחר ההשכמה, הוא מאפס את remainingTime לערך interval המקורי.
    

המטרה של קטעי קוד אלה היא להראות כיצד האחריות לתזמון מרוכזת במקום אחד (AlarmClock), בעוד שהחיישנים (מודולים ברמה גבוהה) רק נרשמים ומחכים לקבל wakeup().

בעיצוב הסופי, **`PressureTrendSensor`** ו-**`AlarmClock`** הן דוגמאות למחלקות שהן **גם צרכניות** של שירותים/מידע **וגם ספקיות** של שירותים/מידע למחלקות אחרות.

---
**קודם:** [[Observer]]
**הבא:** [[Bridge]]

**חזרה ל:** [[מערכת ניטור מזג אוויר (WMS)]]
**תוכן עניינים ראשי:** [[Summeries/עיצוב/תוכן עניינים]]