
---

עבור כל תבנית עיצוב שנלמדה, הסיכום יכלול את שמה, סוגה (יצירה, מבנה, התנהגות) והבעיה הספציפית שהיא פותרת. חשוב לזכור את היישום במקרי בוחן.

## סיכום תבניות

|**נושא**|**נקודות ממוקדות לסיכום**|
|---|---|
|**תבניות יצירה (Creational)**|- **[[Singleton]]:** הגבלת יצירת מופעים למופע יחיד. (חשוב לזכור וריאנט **Thread-Safe**).<br><br>  <br><br>- **[[Abstract Factory]]:** יצירת משפחה של אובייקטים מתואמים, ללא חשיפת המחלקות הקונקרטיות. משמש לאתחול רכיבים ב-Weather Station.<br><br>  <br><br>- **[[Prototype]]:** יצירת אובייקטים חדשים באמצעות שיבוט (cloning) אובייקטים קיימים, ללא צורך להכיר את הטיפוס שלהם.|
|**תבניות מבנה (Structural)**|- **[[Bridge]]:** הפרדה מוחלטת בין הפשטה למימוש, כדי שכל אחת תוכל להתפתח באופן עצמאי. פותר בעיות **DIP**.<br><br>  <br><br>- **[[Decorator]]:** הוספת אחריות/פונקציונליות בזמן ריצה ובצורה גמישה.<br><br>  <br><br>- **[[Composite]]:** צירוף אובייקטים למבנה דמוי עץ כך שהלקוח מתייחס לאובייקטים בודדים ואובייקטים מורכבים בצורה אחידה.<br><br>  <br><br>- **[[Proxy]]:** שליטה בגישה לאובייקט "יקר" או "מוגן". במקרה הבוחן: הפרדת לוגיקת אלגוריתם (**Policy**) מלוגיקת שמירת נתונים (**Persistence**).|
|**תבניות התנהגות (Behavioral)**|- **[[Observer]]:** ניתוק התלות בין ספקי מידע (Observable) לצרכני מידע (Observer).<br><br>  <br><br>- **[[Strategy]]:** הגדרת משפחה של אלגוריתמים ברי החלפה, כאשר הלקוח מכיל מצביע לממשק האלגוריתם. מתאים כאשר האלגוריתם עצמו משתנה לעתים קרובות (כמו שיטות דגימה ב-IRS).<br><br>  <br><br>- **[[Template Method]]:** הגדרת שלד של אלגוריתם במחלקת הבסיס, והשארת חלקים מסוימים ליישום על ידי תתי המחלקות. הבדל מ-**Strategy**: משתמש בירושה, והפונקציה המופשטת היא חלק אינטגרלי מאחריות מחלקת הבסיס.<br><br>  <br><br>- **[[Visitor]]:** הוספת פעולות חדשות על עץ היררכיה מבלי לשנות את המחלקות בעץ.|

---

## מיקוד בתבניות העיקריות והשאלות הגדולות

- תבניות העיצוב (Creational, Structural, ו-Behavioral) המופיעות בתדירות הגבוהה ביותר במבחנים:
    
    - **[[Observer]]** (6 אזכורים)
        
    - **[[Singleton]]** (6 אזכורים)
        
    - **[[Decorator]]** (6 אזכורים)
        
    - **[[Proxy]]** (6 אזכורים)
        
    - **[[Composite]]** (5 אזכורים)
        
    - **[[State]]** (4 אזכורים)
        
    - **[[Visitor]]** (4 אזכורים)
        
- ההבנה של תבניות אלה היא קריטית, כיוון שהן מככבות בשאלות המימוש הפתוחות (לדוגמה: שימוש ב-**[[Visitor]]** לביצוע טסטים על כלי רכב ושימוש ב-**[[Composite]]** וב-**[[Decorator]]** במערכת פורטל החדשות).
    
- **הדגשת יישום הקוד:** להתמקד בלהצליח לכתוב את הקוד של תבנית העיצוב, כדי להצליח בשאלות הפתוחות המעניקות את מרבית הנקודות.
    

---

## תבניות יצירה (Creational Patterns)

תבניות יצירה מטפלות בתהליכי יצירת אובייקטים בצורה גמישה, תוך הפרדת הלקוח מהידע על איך ואיזה אובייקט קונקרטי נוצר.

| **תבנית**                | **מטרה/בעיה נפתרת**                                                                                   | **דמיון/הבדל מרכזי**                                                                                                                                                     | **יישום ממוקד (WMS)**                                                                                               |
| ------------------------ | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| **[[Singleton]]**        | הגבלת יצירת מופעים של מחלקה למופע יחיד בכל המערכת, ומתן נקודת גישה גלובלית אליו.                      | **דמיון:** קשור ל-[[Factory]] כיוון ששתיהן מטפלות ביצירה.<br><br>  <br><br>**הבדל:** [[Singleton]] עוסק בכמות המופעים (אחד), בעוד [[Factory]] עוסק בהפרדת לוגיקת היצירה. | **AlarmClock** ממומש כסינגלטון במערכת מזג האוויר.<br><br>  <br><br>יש להכיר את הווריאנט ה-**Thread-Safe**.          |
| **[[Factory Class]]**    | ריכוז הלוגיקה של יצירת אובייקטים קונקרטיים (המממשים אותו ממשק) במחלקה מרכזית אחת.                     | **הפרת OCP:** המחלקה מפרה **OCP** כיוון שכל הוספת מוצר חדש דורשת שינוי בקוד ה-[[Factory]].                                                                               | משמשת לאתחול אובייקטים עם [[Decorator]]s.                                                                           |
| **[[Factory Method]]**   | העברת אחריות היצירה ליצירת אובייקט לתתי-מחלקות (ConcreteCreators).                                    | **הפרת SRP:** עלולה לגרום להפרת **SRP** אם מחלקת האב (Creator) מחזיקה לוגיקה עסקית וגם את מתודת היצירה.                                                                  |                                                                                                                     |
| **[[Abstract Factory]]** | יצירת משפחות של אובייקטים קשורים (Products) ותיאום הטיפוסים שלהם, כדי להבטיח תאימות בין רכיבים שונים. | **דמייה ל-DI:** ניתן לראות בהרחבה של מושג [[Abstract Factory]] את ההזרקה הבסיסית של תלויות (Dependency Injection).                                                       | **WMS:** משמשת לאתחול גמיש של רכיבי החומרה (כמו חיישנים ושעון) כדי למנוע ערבוב בין גרסאות חומרה (Nimbus 1.0 ו-2.0). |
| **[[Prototype]]**        | יצירת אובייקטים חדשים באמצעות שיבוט (Cloning) אובייקטים קיימים, ללא צורך להכיר את הטיפוס שלהם.        | **מנגנון:** משתמשת בשיבוט במקום יצירה ישירה (Constructor).                                                                                                               |                                                                                                                     |

---

## תבניות התנהגות (Behavioral Patterns)

תבניות התנהגות מזהות תבניות נפוצות של תקשורת בין עצמים, מממשות אותן, ומשמשות לניהול אלגוריתמים, חלוקת אחריות ותקשורת.

|**תבנית**|**השאלה/בעיה העיקרית הנפתרת**|**מנגנון/מבנה**|**דמיון/הבדל מרכזי**|
|---|---|---|---|
|**[[Strategy]]**|"איך פעולה נתונה צריכה להתבצע?"<br><br>  <br><br>הגדרת משפחה של אלגוריתמים ברי החלפה ללא תלות בלקוחות.|**הכלה (Composition)**|**הבדל מ-[[Command]]:**<br><br>  <br><br>[[Strategy]] עונה על "איך" (אלגוריתם), [[Command]] עונה על "מה" (אריזת בקשה).<br><br>  <br><br>**הבדל מ-[[Template Method]]:**<br><br>  <br><br>[[Strategy]] משתמשת בהכלה, ו-[[Template Method]] משתמשת בירושה.|
|**[[Command]]**|"מה צריך להתבצע?"<br><br>  <br><br>כימוס פעולה אחת בצורת אובייקט.|**הכלה (Composition)**, אורזת את הפונקציה, האובייקט והארגומנטים.|**מטרה:** מאפשר העברת פקודה, שמירה לביצוע עתידי או ביטול (**Undo**).<br><br>  <br><br>משמש למאקרו, פעולות או שלט אוניברסלי.|
|**[[Template Method]]**|הגדרת שלד של אלגוריתם קבוע במחלקת הבסיס, והשארת חלקים מסוימים ליישום על ידי תתי-המחלקות ("הכנסת ווים" - Hooks).|**ירושה (Inheritance)**|**WMS:** פתרון לשכפול קוד ולוגיקה זהה (`check()`) בתוך היררכיית החיישנים.|
|**[[Observer]]**|ניתוק התלות בין ספק מידע (**Observable**) לצרכני מידע רבים (**Observer**).|**מנגנון רישום והפצה:** Observable מחזיק רשימה של Observers ומעדכן את כולם בשינוי מצב.|**WMS:** פתרון להפרת **DIP** בין החיישנים לבין ה-MonitoringScreen.|
|**[[Visitor]]**|הוספת פעולה חדשה למחלקות ממשפחה מסוימת (לרוב מבנה [[Composite]]), מבלי לשנות את המחלקות הקיימות.|**Double Dispatch:** מנגנון המבוסס על קריאת `accept(this)` שבתורה קוראת ל-`visit(this)`.|**יתרון OCP/SRP:** מונעת הפרה של **OCP** ו-**SRP** על ידי הוצאת הפעולה למחלקה חיצונית.<br><br>  <br><br>משמש לרוב כמחולל דוחות על מבנה עץ.|
|**[[State]]**|התנהגות האובייקט תלויה במצבו הפנימי, ומאפשרת שינוי התנהגות דרמטי בזמן ריצה.|**הכלה:** האובייקט הראשי (Context) מחזיק רפרנס לממשק **State**, ומחלקות קונקרטיות (ConcreteState) מממשות את ההתנהגות של כל מצב.|משמש למימוש תרשימי מצבים (Statechart), כגון SecretKeeper או Lamp.|
|**[[Iterator]]**|אספקת דרך אחידה לעבור על האיברים של אוסף מבלי לחשוף את המבנה הפנימי של האוסף.|**ממשק:**<br><br>  <br><br>`Iterable<T>`: המחלקה שמכילה את האוסף מממשת `Iterable<T>` ומחזירה מופע של `Iterator<T>`.||

---

### לתבניות הראשונות:
[[תבניות יצירה ( Creational Pattern)]]

### לתוכן עניינים:
[[Summeries/עיצוב/תוכן עניינים]]